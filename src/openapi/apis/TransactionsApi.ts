/* tslint:disable */
/* eslint-disable */
/**
 * Fordefi API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BaseError,
  CreateTransactionRequest,
  CreateTransactionResponse,
  CreateTransactionWithWaitRequest,
  CreateTransactionWithWaitResponse,
  DefinedPreconditionErrorAbortTransactionErrorType,
  DefinedPreconditionErrorApproveTransactionErrorType,
  DefinedPreconditionErrorCreateTransactionErrorType,
  DefinedPreconditionErrorPredictTransactionErrorType,
  DefinedPreconditionErrorReleaseTransactionErrorType,
  DefinedPreconditionErrorSignTransactionErrorType,
  DescribeTransactionRequest,
  DescribeTransactionResponse,
  GetNextApiSignerTransactionResponse,
  GetNextApiSignerTransactionResponseV2,
  GetTransactionResponse,
  ListTransactionResponse,
  NextApiSignerTransactionRequestV3,
  NextApiSignerTransactionResponseV3,
  PreconditionFailedError,
  PredictTransactionRequest,
  PredictTransactionResponse,
  PushTransactionRequest,
  PushTransactionResponse,
  RegisterTransactionSignSessionRequest,
  RegisterTransactionSignSessionResponse,
  ReleaseEvmTransactionRequest,
  ReleaseTransactionResponse,
  ResourceError,
  SignerType,
  TransactionDirection,
  TransactionSortableFields,
  TransactionState,
  TransactionSubType,
  TransactionType,
  TriggerAutoProtectionRequest,
  UpdateTransactionForSigningResponse,
  UpdateTransactionSpamStateRequest,
  ValidationError,
} from '../models';
import {
    BaseErrorFromJSON,
    BaseErrorToJSON,
    CreateTransactionRequestFromJSON,
    CreateTransactionRequestToJSON,
    CreateTransactionResponseFromJSON,
    CreateTransactionResponseToJSON,
    CreateTransactionWithWaitRequestFromJSON,
    CreateTransactionWithWaitRequestToJSON,
    CreateTransactionWithWaitResponseFromJSON,
    CreateTransactionWithWaitResponseToJSON,
    DefinedPreconditionErrorAbortTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorAbortTransactionErrorTypeToJSON,
    DefinedPreconditionErrorApproveTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorApproveTransactionErrorTypeToJSON,
    DefinedPreconditionErrorCreateTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorCreateTransactionErrorTypeToJSON,
    DefinedPreconditionErrorPredictTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorPredictTransactionErrorTypeToJSON,
    DefinedPreconditionErrorReleaseTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorReleaseTransactionErrorTypeToJSON,
    DefinedPreconditionErrorSignTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorSignTransactionErrorTypeToJSON,
    DescribeTransactionRequestFromJSON,
    DescribeTransactionRequestToJSON,
    DescribeTransactionResponseFromJSON,
    DescribeTransactionResponseToJSON,
    GetNextApiSignerTransactionResponseFromJSON,
    GetNextApiSignerTransactionResponseToJSON,
    GetNextApiSignerTransactionResponseV2FromJSON,
    GetNextApiSignerTransactionResponseV2ToJSON,
    GetTransactionResponseFromJSON,
    GetTransactionResponseToJSON,
    ListTransactionResponseFromJSON,
    ListTransactionResponseToJSON,
    NextApiSignerTransactionRequestV3FromJSON,
    NextApiSignerTransactionRequestV3ToJSON,
    NextApiSignerTransactionResponseV3FromJSON,
    NextApiSignerTransactionResponseV3ToJSON,
    PreconditionFailedErrorFromJSON,
    PreconditionFailedErrorToJSON,
    PredictTransactionRequestFromJSON,
    PredictTransactionRequestToJSON,
    PredictTransactionResponseFromJSON,
    PredictTransactionResponseToJSON,
    PushTransactionRequestFromJSON,
    PushTransactionRequestToJSON,
    PushTransactionResponseFromJSON,
    PushTransactionResponseToJSON,
    RegisterTransactionSignSessionRequestFromJSON,
    RegisterTransactionSignSessionRequestToJSON,
    RegisterTransactionSignSessionResponseFromJSON,
    RegisterTransactionSignSessionResponseToJSON,
    ReleaseEvmTransactionRequestFromJSON,
    ReleaseEvmTransactionRequestToJSON,
    ReleaseTransactionResponseFromJSON,
    ReleaseTransactionResponseToJSON,
    ResourceErrorFromJSON,
    ResourceErrorToJSON,
    SignerTypeFromJSON,
    SignerTypeToJSON,
    TransactionDirectionFromJSON,
    TransactionDirectionToJSON,
    TransactionSortableFieldsFromJSON,
    TransactionSortableFieldsToJSON,
    TransactionStateFromJSON,
    TransactionStateToJSON,
    TransactionSubTypeFromJSON,
    TransactionSubTypeToJSON,
    TransactionTypeFromJSON,
    TransactionTypeToJSON,
    TriggerAutoProtectionRequestFromJSON,
    TriggerAutoProtectionRequestToJSON,
    UpdateTransactionForSigningResponseFromJSON,
    UpdateTransactionForSigningResponseToJSON,
    UpdateTransactionSpamStateRequestFromJSON,
    UpdateTransactionSpamStateRequestToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models';

export interface AbortTransactionApiV1TransactionsIdAbortPostRequest {
    id: string;
}

export interface ApproveTransactionApiV1TransactionsIdApprovePostRequest {
    id: string;
}

export interface CreateTransactionAndWaitApiV1TransactionsCreateAndWaitPostRequest {
    createTransactionWithWaitRequest: CreateTransactionWithWaitRequest;
    xSignature?: string;
    xTimestamp?: number;
    xIdempotenceId?: string;
}

export interface CreateTransactionApiV1TransactionsPostRequest {
    createTransactionRequest: CreateTransactionRequest;
    xSignature?: string;
    xTimestamp?: number;
    xIdempotenceId?: string;
}

export interface DescribeTransactionApiV1TransactionsDescribePostRequest {
    describeTransactionRequest: DescribeTransactionRequest;
}

export interface ExportTransactionsApiV1TransactionsExportGetRequest {
    limit?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    modifiedAfter?: Date;
    vaultIds?: Array<string>;
    chains?: Array<string>;
    initiatorIds?: Array<string>;
    types?: Array<TransactionType>;
    subTypes?: Array<TransactionSubType>;
    signerTypes?: Array<SignerType>;
    transactionIds?: Array<string>;
    endUserIds?: Array<string>;
    direction?: TransactionDirection;
}

export interface GetTransactionApiV1TransactionsIdGetRequest {
    id: string;
}

export interface ListTransactionsApiV1TransactionsGetRequest {
    page?: number;
    size?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    modifiedAfter?: Date;
    vaultIds?: Array<string>;
    chains?: Array<string>;
    initiatorIds?: Array<string>;
    types?: Array<TransactionType>;
    subTypes?: Array<TransactionSubType>;
    signerTypes?: Array<SignerType>;
    transactionIds?: Array<string>;
    endUserIds?: Array<string>;
    direction?: TransactionDirection;
    states?: Array<TransactionState>;
    isHidden?: boolean;
    includeFullResponse?: boolean;
    batchIds?: Array<string>;
    sortBy?: Array<TransactionSortableFields>;
}

export interface PredictTransactionApiV1TransactionsPredictPostRequest {
    predictTransactionRequest: PredictTransactionRequest;
}

export interface ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest {
    nextApiSignerTransactionRequestV3: NextApiSignerTransactionRequestV3;
}

export interface PushTransactionApiV1TransactionsIdPushPostRequest {
    id: string;
    pushTransactionRequest: PushTransactionRequest;
}

export interface RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest {
    id: string;
    registerTransactionSignSessionRequest: RegisterTransactionSignSessionRequest;
}

export interface ReleaseTransactionApiV1TransactionsIdReleasePostRequest {
    id: string;
    body: ReleaseEvmTransactionRequest;
    xSignature?: string;
    xTimestamp?: number;
}

export interface SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest {
    id: string;
    body: object;
}

export interface TriggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRequest {
    triggerAutoProtectionRequest: TriggerAutoProtectionRequest;
}

export interface TriggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRequest {
    id: string;
}

export interface UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest {
    id: string;
    body: object;
}

export interface UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest {
    id: string;
    updateTransactionSpamStateRequest: UpdateTransactionSpamStateRequest;
}

/**
 * 
 */
export class TransactionsApi extends runtime.BaseAPI {

    /**
     * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
     * Abort Transaction
     */
    async abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters: AbortTransactionApiV1TransactionsIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling abortTransactionApiV1TransactionsIdAbortPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/abort`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
     * Abort Transaction
     */
    async abortTransactionApiV1TransactionsIdAbortPost(requestParameters: AbortTransactionApiV1TransactionsIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters, initOverrides);
    }

    /**
     * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
     * Approve Transaction
     */
    async approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters: ApproveTransactionApiV1TransactionsIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling approveTransactionApiV1TransactionsIdApprovePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/approve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
     * Approve Transaction
     */
    async approveTransactionApiV1TransactionsIdApprovePost(requestParameters: ApproveTransactionApiV1TransactionsIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new transaction and wait until transaction reaches given state.
     * Create Transaction And Wait
     */
    async createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters: CreateTransactionAndWaitApiV1TransactionsCreateAndWaitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTransactionWithWaitResponse>> {
        if (requestParameters.createTransactionWithWaitRequest === null || requestParameters.createTransactionWithWaitRequest === undefined) {
            throw new runtime.RequiredError('createTransactionWithWaitRequest','Required parameter requestParameters.createTransactionWithWaitRequest was null or undefined when calling createTransactionAndWaitApiV1TransactionsCreateAndWaitPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSignature !== undefined && requestParameters.xSignature !== null) {
            headerParameters['x-signature'] = String(requestParameters.xSignature);
        }

        if (requestParameters.xTimestamp !== undefined && requestParameters.xTimestamp !== null) {
            headerParameters['x-timestamp'] = String(requestParameters.xTimestamp);
        }

        if (requestParameters.xIdempotenceId !== undefined && requestParameters.xIdempotenceId !== null) {
            headerParameters['x-idempotence-id'] = String(requestParameters.xIdempotenceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/create-and-wait`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTransactionWithWaitRequestToJSON(requestParameters.createTransactionWithWaitRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTransactionWithWaitResponseFromJSON(jsonValue));
    }

    /**
     * Create a new transaction and wait until transaction reaches given state.
     * Create Transaction And Wait
     */
    async createTransactionAndWaitApiV1TransactionsCreateAndWaitPost(requestParameters: CreateTransactionAndWaitApiV1TransactionsCreateAndWaitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTransactionWithWaitResponse> {
        const response = await this.createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new transaction.
     * Create Transaction
     */
    async createTransactionApiV1TransactionsPostRaw(requestParameters: CreateTransactionApiV1TransactionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTransactionResponse>> {
        if (requestParameters.createTransactionRequest === null || requestParameters.createTransactionRequest === undefined) {
            throw new runtime.RequiredError('createTransactionRequest','Required parameter requestParameters.createTransactionRequest was null or undefined when calling createTransactionApiV1TransactionsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSignature !== undefined && requestParameters.xSignature !== null) {
            headerParameters['x-signature'] = String(requestParameters.xSignature);
        }

        if (requestParameters.xTimestamp !== undefined && requestParameters.xTimestamp !== null) {
            headerParameters['x-timestamp'] = String(requestParameters.xTimestamp);
        }

        if (requestParameters.xIdempotenceId !== undefined && requestParameters.xIdempotenceId !== null) {
            headerParameters['x-idempotence-id'] = String(requestParameters.xIdempotenceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTransactionRequestToJSON(requestParameters.createTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Create a new transaction.
     * Create Transaction
     */
    async createTransactionApiV1TransactionsPost(requestParameters: CreateTransactionApiV1TransactionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTransactionResponse> {
        const response = await this.createTransactionApiV1TransactionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current blockchain fee price and estimate the total transaction fee.
     * Describe Transaction
     */
    async describeTransactionApiV1TransactionsDescribePostRaw(requestParameters: DescribeTransactionApiV1TransactionsDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DescribeTransactionResponse>> {
        if (requestParameters.describeTransactionRequest === null || requestParameters.describeTransactionRequest === undefined) {
            throw new runtime.RequiredError('describeTransactionRequest','Required parameter requestParameters.describeTransactionRequest was null or undefined when calling describeTransactionApiV1TransactionsDescribePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/describe`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DescribeTransactionRequestToJSON(requestParameters.describeTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DescribeTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get the current blockchain fee price and estimate the total transaction fee.
     * Describe Transaction
     */
    async describeTransactionApiV1TransactionsDescribePost(requestParameters: DescribeTransactionApiV1TransactionsDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DescribeTransactionResponse> {
        const response = await this.describeTransactionApiV1TransactionsDescribePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a CSV-format list of transactions.
     * Export Transactions
     */
    async exportTransactionsApiV1TransactionsExportGetRaw(requestParameters: ExportTransactionsApiV1TransactionsExportGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.createdBefore !== undefined) {
            queryParameters['created_before'] = (requestParameters.createdBefore as any).toISOString();
        }

        if (requestParameters.createdAfter !== undefined) {
            queryParameters['created_after'] = (requestParameters.createdAfter as any).toISOString();
        }

        if (requestParameters.modifiedAfter !== undefined) {
            queryParameters['modified_after'] = (requestParameters.modifiedAfter as any).toISOString();
        }

        if (requestParameters.vaultIds) {
            queryParameters['vault_ids'] = requestParameters.vaultIds;
        }

        if (requestParameters.chains) {
            queryParameters['chains'] = requestParameters.chains;
        }

        if (requestParameters.initiatorIds) {
            queryParameters['initiator_ids'] = requestParameters.initiatorIds;
        }

        if (requestParameters.types) {
            queryParameters['types'] = requestParameters.types;
        }

        if (requestParameters.subTypes) {
            queryParameters['sub_types'] = requestParameters.subTypes;
        }

        if (requestParameters.signerTypes) {
            queryParameters['signer_types'] = requestParameters.signerTypes;
        }

        if (requestParameters.transactionIds) {
            queryParameters['transaction_ids'] = requestParameters.transactionIds;
        }

        if (requestParameters.endUserIds) {
            queryParameters['end_user_ids'] = requestParameters.endUserIds;
        }

        if (requestParameters.direction !== undefined) {
            queryParameters['direction'] = requestParameters.direction;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get a CSV-format list of transactions.
     * Export Transactions
     */
    async exportTransactionsApiV1TransactionsExportGet(requestParameters: ExportTransactionsApiV1TransactionsExportGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportTransactionsApiV1TransactionsExportGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction
     */
    async getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNextApiSignerTransactionResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNextApiSignerTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction
     */
    async getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNextApiSignerTransactionResponse> {
        const response = await this.getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction V2
     */
    async getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2GetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNextApiSignerTransactionResponseV2>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction_v2`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNextApiSignerTransactionResponseV2FromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction V2
     */
    async getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2Get(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNextApiSignerTransactionResponseV2> {
        const response = await this.getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2GetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve transaction details.
     * Get Transaction
     */
    async getTransactionApiV1TransactionsIdGetRaw(requestParameters: GetTransactionApiV1TransactionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTransactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTransactionApiV1TransactionsIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve transaction details.
     * Get Transaction
     */
    async getTransactionApiV1TransactionsIdGet(requestParameters: GetTransactionApiV1TransactionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTransactionResponse> {
        const response = await this.getTransactionApiV1TransactionsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all transactions in an organization.
     * List Transactions
     */
    async listTransactionsApiV1TransactionsGetRaw(requestParameters: ListTransactionsApiV1TransactionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTransactionResponse>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.createdBefore !== undefined) {
            queryParameters['created_before'] = (requestParameters.createdBefore as any).toISOString();
        }

        if (requestParameters.createdAfter !== undefined) {
            queryParameters['created_after'] = (requestParameters.createdAfter as any).toISOString();
        }

        if (requestParameters.modifiedAfter !== undefined) {
            queryParameters['modified_after'] = (requestParameters.modifiedAfter as any).toISOString();
        }

        if (requestParameters.vaultIds) {
            queryParameters['vault_ids'] = requestParameters.vaultIds;
        }

        if (requestParameters.chains) {
            queryParameters['chains'] = requestParameters.chains;
        }

        if (requestParameters.initiatorIds) {
            queryParameters['initiator_ids'] = requestParameters.initiatorIds;
        }

        if (requestParameters.types) {
            queryParameters['types'] = requestParameters.types;
        }

        if (requestParameters.subTypes) {
            queryParameters['sub_types'] = requestParameters.subTypes;
        }

        if (requestParameters.signerTypes) {
            queryParameters['signer_types'] = requestParameters.signerTypes;
        }

        if (requestParameters.transactionIds) {
            queryParameters['transaction_ids'] = requestParameters.transactionIds;
        }

        if (requestParameters.endUserIds) {
            queryParameters['end_user_ids'] = requestParameters.endUserIds;
        }

        if (requestParameters.direction !== undefined) {
            queryParameters['direction'] = requestParameters.direction;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        if (requestParameters.isHidden !== undefined) {
            queryParameters['is_hidden'] = requestParameters.isHidden;
        }

        if (requestParameters.includeFullResponse !== undefined) {
            queryParameters['include_full_response'] = requestParameters.includeFullResponse;
        }

        if (requestParameters.batchIds) {
            queryParameters['batch_ids'] = requestParameters.batchIds;
        }

        if (requestParameters.sortBy) {
            queryParameters['sort_by'] = requestParameters.sortBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all transactions in an organization.
     * List Transactions
     */
    async listTransactionsApiV1TransactionsGet(requestParameters: ListTransactionsApiV1TransactionsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTransactionResponse> {
        const response = await this.listTransactionsApiV1TransactionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Simulate the transaction and show the exact token\'s balance change, in addition to the fee estimation.
     * Predict Transaction
     */
    async predictTransactionApiV1TransactionsPredictPostRaw(requestParameters: PredictTransactionApiV1TransactionsPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PredictTransactionResponse>> {
        if (requestParameters.predictTransactionRequest === null || requestParameters.predictTransactionRequest === undefined) {
            throw new runtime.RequiredError('predictTransactionRequest','Required parameter requestParameters.predictTransactionRequest was null or undefined when calling predictTransactionApiV1TransactionsPredictPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/predict`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PredictTransactionRequestToJSON(requestParameters.predictTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PredictTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Simulate the transaction and show the exact token\'s balance change, in addition to the fee estimation.
     * Predict Transaction
     */
    async predictTransactionApiV1TransactionsPredictPost(requestParameters: PredictTransactionApiV1TransactionsPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PredictTransactionResponse> {
        const response = await this.predictTransactionApiV1TransactionsPredictPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V3
     */
    async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters: ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextApiSignerTransactionResponseV3>> {
        if (requestParameters.nextApiSignerTransactionRequestV3 === null || requestParameters.nextApiSignerTransactionRequestV3 === undefined) {
            throw new runtime.RequiredError('nextApiSignerTransactionRequestV3','Required parameter requestParameters.nextApiSignerTransactionRequestV3 was null or undefined when calling processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction_v3`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NextApiSignerTransactionRequestV3ToJSON(requestParameters.nextApiSignerTransactionRequestV3),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextApiSignerTransactionResponseV3FromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V3
     */
    async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post(requestParameters: ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextApiSignerTransactionResponseV3> {
        const response = await this.processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Push a transaction to the chain.
     * Push Transaction
     */
    async pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters: PushTransactionApiV1TransactionsIdPushPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PushTransactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost.');
        }

        if (requestParameters.pushTransactionRequest === null || requestParameters.pushTransactionRequest === undefined) {
            throw new runtime.RequiredError('pushTransactionRequest','Required parameter requestParameters.pushTransactionRequest was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/push`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PushTransactionRequestToJSON(requestParameters.pushTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PushTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Push a transaction to the chain.
     * Push Transaction
     */
    async pushTransactionApiV1TransactionsIdPushPost(requestParameters: PushTransactionApiV1TransactionsIdPushPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PushTransactionResponse> {
        const response = await this.pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a sign-session for a transaction.
     * Register Transaction Sign Session
     */
    async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters: RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegisterTransactionSignSessionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost.');
        }

        if (requestParameters.registerTransactionSignSessionRequest === null || requestParameters.registerTransactionSignSessionRequest === undefined) {
            throw new runtime.RequiredError('registerTransactionSignSessionRequest','Required parameter requestParameters.registerTransactionSignSessionRequest was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/register-sign-session`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterTransactionSignSessionRequestToJSON(requestParameters.registerTransactionSignSessionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegisterTransactionSignSessionResponseFromJSON(jsonValue));
    }

    /**
     * Register a sign-session for a transaction.
     * Register Transaction Sign Session
     */
    async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost(requestParameters: RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegisterTransactionSignSessionResponse> {
        const response = await this.registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Release a transaction.
     * Release Transaction
     */
    async releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters: ReleaseTransactionApiV1TransactionsIdReleasePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReleaseTransactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSignature !== undefined && requestParameters.xSignature !== null) {
            headerParameters['x-signature'] = String(requestParameters.xSignature);
        }

        if (requestParameters.xTimestamp !== undefined && requestParameters.xTimestamp !== null) {
            headerParameters['x-timestamp'] = String(requestParameters.xTimestamp);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/release`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReleaseEvmTransactionRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Release a transaction.
     * Release Transaction
     */
    async releaseTransactionApiV1TransactionsIdReleasePost(requestParameters: ReleaseTransactionApiV1TransactionsIdReleasePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReleaseTransactionResponse> {
        const response = await this.releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a signature for a transaction.
     * Submit Transaction Signature
     */
    async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters: SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/submit-signature`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Submit a signature for a transaction.
     * Submit Transaction Signature
     */
    async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost(requestParameters: SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trigger transaction auto revoke protection.
     * Trigger Auto Revoke Protection
     */
    async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters: TriggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.triggerAutoProtectionRequest === null || requestParameters.triggerAutoProtectionRequest === undefined) {
            throw new runtime.RequiredError('triggerAutoProtectionRequest','Required parameter requestParameters.triggerAutoProtectionRequest was null or undefined when calling triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/trigger-auto-revoke-protection`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TriggerAutoProtectionRequestToJSON(requestParameters.triggerAutoProtectionRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger transaction auto revoke protection.
     * Trigger Auto Revoke Protection
     */
    async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost(requestParameters: TriggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters, initOverrides);
    }

    /**
     * Trigger transaction signing.
     * Trigger Transaction Signing
     */
    async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters: TriggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/trigger-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger transaction signing.
     * Trigger Transaction Signing
     */
    async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost(requestParameters: TriggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters, initOverrides);
    }

    /**
     * Update a transaction before signing it.
     * Update Transaction For Signing
     */
    async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters: UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateTransactionForSigningResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/update-for-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateTransactionForSigningResponseFromJSON(jsonValue));
    }

    /**
     * Update a transaction before signing it.
     * Update Transaction For Signing
     */
    async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost(requestParameters: UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateTransactionForSigningResponse> {
        const response = await this.updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update transaction\'s spam state.
     * Update Transaction Spam State
     */
    async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters: UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut.');
        }

        if (requestParameters.updateTransactionSpamStateRequest === null || requestParameters.updateTransactionSpamStateRequest === undefined) {
            throw new runtime.RequiredError('updateTransactionSpamStateRequest','Required parameter requestParameters.updateTransactionSpamStateRequest was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/update-spam-state`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTransactionSpamStateRequestToJSON(requestParameters.updateTransactionSpamStateRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update transaction\'s spam state.
     * Update Transaction Spam State
     */
    async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut(requestParameters: UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ExportTransactionsApiV1TransactionsExportGetChainsEnum = {
    aptosMainnet: 'aptos_mainnet',
    aptosTestnet: 'aptos_testnet',
    cosmosAgoric3: 'cosmos_agoric-3',
    cosmosAkashnet2: 'cosmos_akashnet-2',
    cosmosArchway1: 'cosmos_archway-1',
    cosmosAxelarDojo1: 'cosmos_axelar-dojo-1',
    cosmosCelestia: 'cosmos_celestia',
    cosmosCosmoshub4: 'cosmos_cosmoshub-4',
    cosmosDydxMainnet1: 'cosmos_dydx-mainnet-1',
    cosmosDydxTestnet4: 'cosmos_dydx-testnet-4',
    cosmosDymension11001: 'cosmos_dymension_1100-1',
    cosmosNeutron1: 'cosmos_neutron-1',
    cosmosNoble1: 'cosmos_noble-1',
    cosmosOsmosis1: 'cosmos_osmosis-1',
    cosmosPacific1: 'cosmos_pacific-1',
    cosmosStride1: 'cosmos_stride-1',
    evm1: 'evm_1',
    evm5: 'evm_5',
    evm10: 'evm_10',
    evm16: 'evm_16',
    evm56: 'evm_56',
    evm100: 'evm_100',
    evm137: 'evm_137',
    evm169: 'evm_169',
    evm250: 'evm_250',
    evm324: 'evm_324',
    evm1030: 'evm_1030',
    evm1100: 'evm_1100',
    evm1101: 'evm_1101',
    evm1329: 'evm_1329',
    evm1729: 'evm_1729',
    evm2222: 'evm_2222',
    evm4200: 'evm_4200',
    evm5000: 'evm_5000',
    evm7000: 'evm_7000',
    evm7700: 'evm_7700',
    evm8453: 'evm_8453',
    evm17000: 'evm_17000',
    evm80001: 'evm_80001',
    evm42161: 'evm_42161',
    evm43114: 'evm_43114',
    evm59144: 'evm_59144',
    evm81457: 'evm_81457',
    evm421614: 'evm_421614',
    evm534352: 'evm_534352',
    evm660279: 'evm_660279',
    evm810180: 'evm_810180',
    evm11155111: 'evm_11155111',
    evmEthereumMainnet: 'evm_ethereum_mainnet',
    evmEthereumGoerli: 'evm_ethereum_goerli',
    evmOptimismMainnet: 'evm_optimism_mainnet',
    evmFlareTestnet: 'evm_flare_testnet',
    evmBscMainnet: 'evm_bsc_mainnet',
    evmGnosisMainnet: 'evm_gnosis_mainnet',
    evmPolygonMainnet: 'evm_polygon_mainnet',
    evmMantaPacificMainnet: 'evm_manta_pacific_mainnet',
    evmFantomMainnet: 'evm_fantom_mainnet',
    evmZksyncEraMainnet: 'evm_zksync_era_mainnet',
    evmConfluxMainnet: 'evm_conflux_mainnet',
    evmDymensionMainnet: 'evm_dymension_mainnet',
    evmPolygonZkevmMainnet: 'evm_polygon_zkevm_mainnet',
    evmSeiMainnet: 'evm_sei_mainnet',
    evmReyaMainnet: 'evm_reya_mainnet',
    evmKavaMainnet: 'evm_kava_mainnet',
    evmMerlinMainnet: 'evm_merlin_mainnet',
    evmMantleMainnet: 'evm_mantle_mainnet',
    evmZetaMainnet: 'evm_zeta_mainnet',
    evmCantoMainnet: 'evm_canto_mainnet',
    evmBaseMainnet: 'evm_base_mainnet',
    evmEthereumHolesky: 'evm_ethereum_holesky',
    evmPolygonMumbai: 'evm_polygon_mumbai',
    evmArbitrumMainnet: 'evm_arbitrum_mainnet',
    evmAvalancheChain: 'evm_avalanche_chain',
    evmLineaMainnet: 'evm_linea_mainnet',
    evmBlastMainnet: 'evm_blast_mainnet',
    evmArbitrumSepolia: 'evm_arbitrum_sepolia',
    evmScrollMainnet: 'evm_scroll_mainnet',
    evmXaiMainnet: 'evm_xai_mainnet',
    evmZklinkNovaMainnet: 'evm_zklink_nova_mainnet',
    evmEthereumSepolia: 'evm_ethereum_sepolia',
    solanaMainnet: 'solana_mainnet',
    solanaDevnet: 'solana_devnet',
    suiMainnet: 'sui_mainnet',
    suiTestnet: 'sui_testnet',
    bitcoinMainnet: 'bitcoin_mainnet',
    bitcoinTestnet: 'bitcoin_testnet'
} as const;
export type ExportTransactionsApiV1TransactionsExportGetChainsEnum = typeof ExportTransactionsApiV1TransactionsExportGetChainsEnum[keyof typeof ExportTransactionsApiV1TransactionsExportGetChainsEnum];
/**
 * @export
 */
export const ListTransactionsApiV1TransactionsGetChainsEnum = {
    aptosMainnet: 'aptos_mainnet',
    aptosTestnet: 'aptos_testnet',
    cosmosAgoric3: 'cosmos_agoric-3',
    cosmosAkashnet2: 'cosmos_akashnet-2',
    cosmosArchway1: 'cosmos_archway-1',
    cosmosAxelarDojo1: 'cosmos_axelar-dojo-1',
    cosmosCelestia: 'cosmos_celestia',
    cosmosCosmoshub4: 'cosmos_cosmoshub-4',
    cosmosDydxMainnet1: 'cosmos_dydx-mainnet-1',
    cosmosDydxTestnet4: 'cosmos_dydx-testnet-4',
    cosmosDymension11001: 'cosmos_dymension_1100-1',
    cosmosNeutron1: 'cosmos_neutron-1',
    cosmosNoble1: 'cosmos_noble-1',
    cosmosOsmosis1: 'cosmos_osmosis-1',
    cosmosPacific1: 'cosmos_pacific-1',
    cosmosStride1: 'cosmos_stride-1',
    evm1: 'evm_1',
    evm5: 'evm_5',
    evm10: 'evm_10',
    evm16: 'evm_16',
    evm56: 'evm_56',
    evm100: 'evm_100',
    evm137: 'evm_137',
    evm169: 'evm_169',
    evm250: 'evm_250',
    evm324: 'evm_324',
    evm1030: 'evm_1030',
    evm1100: 'evm_1100',
    evm1101: 'evm_1101',
    evm1329: 'evm_1329',
    evm1729: 'evm_1729',
    evm2222: 'evm_2222',
    evm4200: 'evm_4200',
    evm5000: 'evm_5000',
    evm7000: 'evm_7000',
    evm7700: 'evm_7700',
    evm8453: 'evm_8453',
    evm17000: 'evm_17000',
    evm80001: 'evm_80001',
    evm42161: 'evm_42161',
    evm43114: 'evm_43114',
    evm59144: 'evm_59144',
    evm81457: 'evm_81457',
    evm421614: 'evm_421614',
    evm534352: 'evm_534352',
    evm660279: 'evm_660279',
    evm810180: 'evm_810180',
    evm11155111: 'evm_11155111',
    evmEthereumMainnet: 'evm_ethereum_mainnet',
    evmEthereumGoerli: 'evm_ethereum_goerli',
    evmOptimismMainnet: 'evm_optimism_mainnet',
    evmFlareTestnet: 'evm_flare_testnet',
    evmBscMainnet: 'evm_bsc_mainnet',
    evmGnosisMainnet: 'evm_gnosis_mainnet',
    evmPolygonMainnet: 'evm_polygon_mainnet',
    evmMantaPacificMainnet: 'evm_manta_pacific_mainnet',
    evmFantomMainnet: 'evm_fantom_mainnet',
    evmZksyncEraMainnet: 'evm_zksync_era_mainnet',
    evmConfluxMainnet: 'evm_conflux_mainnet',
    evmDymensionMainnet: 'evm_dymension_mainnet',
    evmPolygonZkevmMainnet: 'evm_polygon_zkevm_mainnet',
    evmSeiMainnet: 'evm_sei_mainnet',
    evmReyaMainnet: 'evm_reya_mainnet',
    evmKavaMainnet: 'evm_kava_mainnet',
    evmMerlinMainnet: 'evm_merlin_mainnet',
    evmMantleMainnet: 'evm_mantle_mainnet',
    evmZetaMainnet: 'evm_zeta_mainnet',
    evmCantoMainnet: 'evm_canto_mainnet',
    evmBaseMainnet: 'evm_base_mainnet',
    evmEthereumHolesky: 'evm_ethereum_holesky',
    evmPolygonMumbai: 'evm_polygon_mumbai',
    evmArbitrumMainnet: 'evm_arbitrum_mainnet',
    evmAvalancheChain: 'evm_avalanche_chain',
    evmLineaMainnet: 'evm_linea_mainnet',
    evmBlastMainnet: 'evm_blast_mainnet',
    evmArbitrumSepolia: 'evm_arbitrum_sepolia',
    evmScrollMainnet: 'evm_scroll_mainnet',
    evmXaiMainnet: 'evm_xai_mainnet',
    evmZklinkNovaMainnet: 'evm_zklink_nova_mainnet',
    evmEthereumSepolia: 'evm_ethereum_sepolia',
    solanaMainnet: 'solana_mainnet',
    solanaDevnet: 'solana_devnet',
    suiMainnet: 'sui_mainnet',
    suiTestnet: 'sui_testnet',
    bitcoinMainnet: 'bitcoin_mainnet',
    bitcoinTestnet: 'bitcoin_testnet'
} as const;
export type ListTransactionsApiV1TransactionsGetChainsEnum = typeof ListTransactionsApiV1TransactionsGetChainsEnum[keyof typeof ListTransactionsApiV1TransactionsGetChainsEnum];
