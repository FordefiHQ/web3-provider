/* tslint:disable */
/* eslint-disable */
/**
 * Fordefi API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BaseError,
  BulkCreateTransactionRequest,
  BulkCreateTransactionResponse,
  BulkDescribeTransactionRequest,
  BulkDescribeTransactionResponse,
  BulkPredictTransactionRequest,
  BulkPredictTransactionResponse,
  ChainUniqueId,
  CreateTransactionRequest,
  CreateTransactionResponse,
  CreateTransactionWithWaitRequest,
  CreateTransactionWithWaitResponse,
  DefinedPreconditionErrorAbortTransactionErrorType,
  DefinedPreconditionErrorApproveTransactionErrorType,
  DefinedPreconditionErrorCreateTransactionErrorType,
  DefinedPreconditionErrorPredictTransactionErrorType,
  DefinedPreconditionErrorReleaseTransactionErrorType,
  DefinedPreconditionErrorSignTransactionErrorType,
  DescribeTransactionRequest,
  DescribeTransactionResponse,
  GetNextApiSignerTransactionResponse,
  GetNextApiSignerTransactionResponseV2,
  GetTransactionResponse,
  ListTransactionResponse,
  NextApiSignerTransactionRequestV3,
  NextApiSignerTransactionResponseV3,
  PreconditionFailedError,
  PredictTransactionRequest,
  PredictTransactionResponse,
  PushTransactionRequest,
  PushTransactionResponse,
  RegisterTransactionSignSessionRequest,
  RegisterTransactionSignSessionResponse,
  ReleaseEvmTransactionRequest,
  ReleaseTransactionResponse,
  ResourceError,
  SignerType,
  TransactionDirection,
  TransactionSortableFields,
  TransactionState,
  TransactionSubType,
  TransactionType,
  UpdateTransactionForSigningResponse,
  UpdateTransactionSpamStateRequest,
  ValidationError,
} from '../models';
import {
    BaseErrorFromJSON,
    BaseErrorToJSON,
    BulkCreateTransactionRequestFromJSON,
    BulkCreateTransactionRequestToJSON,
    BulkCreateTransactionResponseFromJSON,
    BulkCreateTransactionResponseToJSON,
    BulkDescribeTransactionRequestFromJSON,
    BulkDescribeTransactionRequestToJSON,
    BulkDescribeTransactionResponseFromJSON,
    BulkDescribeTransactionResponseToJSON,
    BulkPredictTransactionRequestFromJSON,
    BulkPredictTransactionRequestToJSON,
    BulkPredictTransactionResponseFromJSON,
    BulkPredictTransactionResponseToJSON,
    ChainUniqueIdFromJSON,
    ChainUniqueIdToJSON,
    CreateTransactionRequestFromJSON,
    CreateTransactionRequestToJSON,
    CreateTransactionResponseFromJSON,
    CreateTransactionResponseToJSON,
    CreateTransactionWithWaitRequestFromJSON,
    CreateTransactionWithWaitRequestToJSON,
    CreateTransactionWithWaitResponseFromJSON,
    CreateTransactionWithWaitResponseToJSON,
    DefinedPreconditionErrorAbortTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorAbortTransactionErrorTypeToJSON,
    DefinedPreconditionErrorApproveTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorApproveTransactionErrorTypeToJSON,
    DefinedPreconditionErrorCreateTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorCreateTransactionErrorTypeToJSON,
    DefinedPreconditionErrorPredictTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorPredictTransactionErrorTypeToJSON,
    DefinedPreconditionErrorReleaseTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorReleaseTransactionErrorTypeToJSON,
    DefinedPreconditionErrorSignTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorSignTransactionErrorTypeToJSON,
    DescribeTransactionRequestFromJSON,
    DescribeTransactionRequestToJSON,
    DescribeTransactionResponseFromJSON,
    DescribeTransactionResponseToJSON,
    GetNextApiSignerTransactionResponseFromJSON,
    GetNextApiSignerTransactionResponseToJSON,
    GetNextApiSignerTransactionResponseV2FromJSON,
    GetNextApiSignerTransactionResponseV2ToJSON,
    GetTransactionResponseFromJSON,
    GetTransactionResponseToJSON,
    ListTransactionResponseFromJSON,
    ListTransactionResponseToJSON,
    NextApiSignerTransactionRequestV3FromJSON,
    NextApiSignerTransactionRequestV3ToJSON,
    NextApiSignerTransactionResponseV3FromJSON,
    NextApiSignerTransactionResponseV3ToJSON,
    PreconditionFailedErrorFromJSON,
    PreconditionFailedErrorToJSON,
    PredictTransactionRequestFromJSON,
    PredictTransactionRequestToJSON,
    PredictTransactionResponseFromJSON,
    PredictTransactionResponseToJSON,
    PushTransactionRequestFromJSON,
    PushTransactionRequestToJSON,
    PushTransactionResponseFromJSON,
    PushTransactionResponseToJSON,
    RegisterTransactionSignSessionRequestFromJSON,
    RegisterTransactionSignSessionRequestToJSON,
    RegisterTransactionSignSessionResponseFromJSON,
    RegisterTransactionSignSessionResponseToJSON,
    ReleaseEvmTransactionRequestFromJSON,
    ReleaseEvmTransactionRequestToJSON,
    ReleaseTransactionResponseFromJSON,
    ReleaseTransactionResponseToJSON,
    ResourceErrorFromJSON,
    ResourceErrorToJSON,
    SignerTypeFromJSON,
    SignerTypeToJSON,
    TransactionDirectionFromJSON,
    TransactionDirectionToJSON,
    TransactionSortableFieldsFromJSON,
    TransactionSortableFieldsToJSON,
    TransactionStateFromJSON,
    TransactionStateToJSON,
    TransactionSubTypeFromJSON,
    TransactionSubTypeToJSON,
    TransactionTypeFromJSON,
    TransactionTypeToJSON,
    UpdateTransactionForSigningResponseFromJSON,
    UpdateTransactionForSigningResponseToJSON,
    UpdateTransactionSpamStateRequestFromJSON,
    UpdateTransactionSpamStateRequestToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models';

export interface AbortTransactionApiV1TransactionsIdAbortPostRequest {
    id: string;
}

export interface ApproveTransactionApiV1TransactionsIdApprovePostRequest {
    id: string;
}

export interface BulkAbortTransactionsApiV1TransactionsBulkBatchIdAbortPostRequest {
    batchId: string;
}

export interface BulkApproveTransactionsApiV1TransactionsBulkBatchIdApprovePostRequest {
    batchId: string;
}

export interface BulkCreateTransactionsApiV1TransactionsBulkPostRequest {
    bulkCreateTransactionRequest: BulkCreateTransactionRequest;
    xSignature?: string;
    xTimestamp?: number;
    xIdempotenceId?: string;
}

export interface BulkDescribeTransactionsApiV1TransactionsBulkDescribePostRequest {
    bulkDescribeTransactionRequest: BulkDescribeTransactionRequest;
}

export interface BulkPredictTransactionsApiV1TransactionsBulkPredictPostRequest {
    bulkPredictTransactionRequest: BulkPredictTransactionRequest;
}

export interface CreateTransactionApiV1TransactionsPostRequest {
    createTransactionRequest: CreateTransactionRequest;
    xSignature?: string;
    xTimestamp?: number;
    xIdempotenceId?: string;
}

export interface CreateTransactionWithWaitApiV1TransactionsCreateWithWaitPostRequest {
    createTransactionWithWaitRequest: CreateTransactionWithWaitRequest;
    xSignature?: string;
    xTimestamp?: number;
    xIdempotenceId?: string;
}

export interface DescribeTransactionApiV1TransactionsDescribePostRequest {
    describeTransactionRequest: DescribeTransactionRequest;
}

export interface GetTransactionApiV1TransactionsIdGetRequest {
    id: string;
}

export interface ListTransactionsApiV1TransactionsGetRequest {
    page?: number;
    size?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    modifiedAfter?: Date;
    vaultIds?: Array<string>;
    chains?: Array<ChainUniqueId>;
    initiatorIds?: Array<string>;
    states?: Array<TransactionState>;
    types?: Array<TransactionType>;
    subTypes?: Array<TransactionSubType>;
    signerTypes?: Array<SignerType>;
    transactionIds?: Array<string>;
    endUserIds?: Array<string>;
    isHidden?: boolean;
    direction?: TransactionDirection;
    includeFullResponse?: boolean;
    sortBy?: Array<TransactionSortableFields>;
}

export interface PredictTransactionApiV1TransactionsPredictPostRequest {
    predictTransactionRequest: PredictTransactionRequest;
}

export interface ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest {
    nextApiSignerTransactionRequestV3: NextApiSignerTransactionRequestV3;
}

export interface PushTransactionApiV1TransactionsIdPushPostRequest {
    id: string;
    pushTransactionRequest: PushTransactionRequest;
}

export interface RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest {
    id: string;
    registerTransactionSignSessionRequest: RegisterTransactionSignSessionRequest;
}

export interface ReleaseTransactionApiV1TransactionsIdReleasePostRequest {
    id: string;
    body: ReleaseEvmTransactionRequest;
    xSignature?: string;
    xTimestamp?: number;
}

export interface SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest {
    id: string;
    body: object;
}

export interface UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest {
    id: string;
    body: object;
}

export interface UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest {
    id: string;
    updateTransactionSpamStateRequest: UpdateTransactionSpamStateRequest;
}

/**
 * 
 */
export class TransactionsApi extends runtime.BaseAPI {

    /**
     * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
     * Abort Transaction
     */
    async abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters: AbortTransactionApiV1TransactionsIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling abortTransactionApiV1TransactionsIdAbortPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/abort`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
     * Abort Transaction
     */
    async abortTransactionApiV1TransactionsIdAbortPost(requestParameters: AbortTransactionApiV1TransactionsIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters, initOverrides);
    }

    /**
     * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
     * Approve Transaction
     */
    async approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters: ApproveTransactionApiV1TransactionsIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling approveTransactionApiV1TransactionsIdApprovePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/approve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
     * Approve Transaction
     */
    async approveTransactionApiV1TransactionsIdApprovePost(requestParameters: ApproveTransactionApiV1TransactionsIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters, initOverrides);
    }

    /**
     * Abort a batch of transactions.
     * Bulk Abort Transactions
     */
    async bulkAbortTransactionsApiV1TransactionsBulkBatchIdAbortPostRaw(requestParameters: BulkAbortTransactionsApiV1TransactionsBulkBatchIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.batchId === null || requestParameters.batchId === undefined) {
            throw new runtime.RequiredError('batchId','Required parameter requestParameters.batchId was null or undefined when calling bulkAbortTransactionsApiV1TransactionsBulkBatchIdAbortPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/bulk/{batch_id}/abort`.replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters.batchId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Abort a batch of transactions.
     * Bulk Abort Transactions
     */
    async bulkAbortTransactionsApiV1TransactionsBulkBatchIdAbortPost(requestParameters: BulkAbortTransactionsApiV1TransactionsBulkBatchIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bulkAbortTransactionsApiV1TransactionsBulkBatchIdAbortPostRaw(requestParameters, initOverrides);
    }

    /**
     * Approve a batch of transactions.
     * Bulk Approve Transactions
     */
    async bulkApproveTransactionsApiV1TransactionsBulkBatchIdApprovePostRaw(requestParameters: BulkApproveTransactionsApiV1TransactionsBulkBatchIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.batchId === null || requestParameters.batchId === undefined) {
            throw new runtime.RequiredError('batchId','Required parameter requestParameters.batchId was null or undefined when calling bulkApproveTransactionsApiV1TransactionsBulkBatchIdApprovePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/bulk/{batch_id}/approve`.replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters.batchId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Approve a batch of transactions.
     * Bulk Approve Transactions
     */
    async bulkApproveTransactionsApiV1TransactionsBulkBatchIdApprovePost(requestParameters: BulkApproveTransactionsApiV1TransactionsBulkBatchIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bulkApproveTransactionsApiV1TransactionsBulkBatchIdApprovePostRaw(requestParameters, initOverrides);
    }

    /**
     * Create a batch of transactions.
     * Bulk Create Transactions
     */
    async bulkCreateTransactionsApiV1TransactionsBulkPostRaw(requestParameters: BulkCreateTransactionsApiV1TransactionsBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkCreateTransactionResponse>> {
        if (requestParameters.bulkCreateTransactionRequest === null || requestParameters.bulkCreateTransactionRequest === undefined) {
            throw new runtime.RequiredError('bulkCreateTransactionRequest','Required parameter requestParameters.bulkCreateTransactionRequest was null or undefined when calling bulkCreateTransactionsApiV1TransactionsBulkPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSignature !== undefined && requestParameters.xSignature !== null) {
            headerParameters['x-signature'] = String(requestParameters.xSignature);
        }

        if (requestParameters.xTimestamp !== undefined && requestParameters.xTimestamp !== null) {
            headerParameters['x-timestamp'] = String(requestParameters.xTimestamp);
        }

        if (requestParameters.xIdempotenceId !== undefined && requestParameters.xIdempotenceId !== null) {
            headerParameters['x-idempotence-id'] = String(requestParameters.xIdempotenceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/bulk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkCreateTransactionRequestToJSON(requestParameters.bulkCreateTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BulkCreateTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Create a batch of transactions.
     * Bulk Create Transactions
     */
    async bulkCreateTransactionsApiV1TransactionsBulkPost(requestParameters: BulkCreateTransactionsApiV1TransactionsBulkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkCreateTransactionResponse> {
        const response = await this.bulkCreateTransactionsApiV1TransactionsBulkPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current blockchain fee price and estimate the total transaction fee for the batch of transactions.
     * Bulk Describe Transactions
     */
    async bulkDescribeTransactionsApiV1TransactionsBulkDescribePostRaw(requestParameters: BulkDescribeTransactionsApiV1TransactionsBulkDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkDescribeTransactionResponse>> {
        if (requestParameters.bulkDescribeTransactionRequest === null || requestParameters.bulkDescribeTransactionRequest === undefined) {
            throw new runtime.RequiredError('bulkDescribeTransactionRequest','Required parameter requestParameters.bulkDescribeTransactionRequest was null or undefined when calling bulkDescribeTransactionsApiV1TransactionsBulkDescribePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/bulk/describe`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkDescribeTransactionRequestToJSON(requestParameters.bulkDescribeTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BulkDescribeTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get the current blockchain fee price and estimate the total transaction fee for the batch of transactions.
     * Bulk Describe Transactions
     */
    async bulkDescribeTransactionsApiV1TransactionsBulkDescribePost(requestParameters: BulkDescribeTransactionsApiV1TransactionsBulkDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkDescribeTransactionResponse> {
        const response = await this.bulkDescribeTransactionsApiV1TransactionsBulkDescribePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Simulate the batch of transactions and show the exact token\'s balance change, in addition to the fee estimation.
     * Bulk Predict Transactions
     */
    async bulkPredictTransactionsApiV1TransactionsBulkPredictPostRaw(requestParameters: BulkPredictTransactionsApiV1TransactionsBulkPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BulkPredictTransactionResponse>> {
        if (requestParameters.bulkPredictTransactionRequest === null || requestParameters.bulkPredictTransactionRequest === undefined) {
            throw new runtime.RequiredError('bulkPredictTransactionRequest','Required parameter requestParameters.bulkPredictTransactionRequest was null or undefined when calling bulkPredictTransactionsApiV1TransactionsBulkPredictPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/bulk/predict`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BulkPredictTransactionRequestToJSON(requestParameters.bulkPredictTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BulkPredictTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Simulate the batch of transactions and show the exact token\'s balance change, in addition to the fee estimation.
     * Bulk Predict Transactions
     */
    async bulkPredictTransactionsApiV1TransactionsBulkPredictPost(requestParameters: BulkPredictTransactionsApiV1TransactionsBulkPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BulkPredictTransactionResponse> {
        const response = await this.bulkPredictTransactionsApiV1TransactionsBulkPredictPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new transaction.
     * Create Transaction
     */
    async createTransactionApiV1TransactionsPostRaw(requestParameters: CreateTransactionApiV1TransactionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTransactionResponse>> {
        if (requestParameters.createTransactionRequest === null || requestParameters.createTransactionRequest === undefined) {
            throw new runtime.RequiredError('createTransactionRequest','Required parameter requestParameters.createTransactionRequest was null or undefined when calling createTransactionApiV1TransactionsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSignature !== undefined && requestParameters.xSignature !== null) {
            headerParameters['x-signature'] = String(requestParameters.xSignature);
        }

        if (requestParameters.xTimestamp !== undefined && requestParameters.xTimestamp !== null) {
            headerParameters['x-timestamp'] = String(requestParameters.xTimestamp);
        }

        if (requestParameters.xIdempotenceId !== undefined && requestParameters.xIdempotenceId !== null) {
            headerParameters['x-idempotence-id'] = String(requestParameters.xIdempotenceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTransactionRequestToJSON(requestParameters.createTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Create a new transaction.
     * Create Transaction
     */
    async createTransactionApiV1TransactionsPost(requestParameters: CreateTransactionApiV1TransactionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTransactionResponse> {
        const response = await this.createTransactionApiV1TransactionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new transaction and wait until transaction reaches given state.
     * Create Transaction With Wait
     */
    async createTransactionWithWaitApiV1TransactionsCreateWithWaitPostRaw(requestParameters: CreateTransactionWithWaitApiV1TransactionsCreateWithWaitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTransactionWithWaitResponse>> {
        if (requestParameters.createTransactionWithWaitRequest === null || requestParameters.createTransactionWithWaitRequest === undefined) {
            throw new runtime.RequiredError('createTransactionWithWaitRequest','Required parameter requestParameters.createTransactionWithWaitRequest was null or undefined when calling createTransactionWithWaitApiV1TransactionsCreateWithWaitPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSignature !== undefined && requestParameters.xSignature !== null) {
            headerParameters['x-signature'] = String(requestParameters.xSignature);
        }

        if (requestParameters.xTimestamp !== undefined && requestParameters.xTimestamp !== null) {
            headerParameters['x-timestamp'] = String(requestParameters.xTimestamp);
        }

        if (requestParameters.xIdempotenceId !== undefined && requestParameters.xIdempotenceId !== null) {
            headerParameters['x-idempotence-id'] = String(requestParameters.xIdempotenceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/create-with-wait`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTransactionWithWaitRequestToJSON(requestParameters.createTransactionWithWaitRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTransactionWithWaitResponseFromJSON(jsonValue));
    }

    /**
     * Create a new transaction and wait until transaction reaches given state.
     * Create Transaction With Wait
     */
    async createTransactionWithWaitApiV1TransactionsCreateWithWaitPost(requestParameters: CreateTransactionWithWaitApiV1TransactionsCreateWithWaitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTransactionWithWaitResponse> {
        const response = await this.createTransactionWithWaitApiV1TransactionsCreateWithWaitPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current blockchain fee price and estimate the total transaction fee.
     * Describe Transaction
     */
    async describeTransactionApiV1TransactionsDescribePostRaw(requestParameters: DescribeTransactionApiV1TransactionsDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DescribeTransactionResponse>> {
        if (requestParameters.describeTransactionRequest === null || requestParameters.describeTransactionRequest === undefined) {
            throw new runtime.RequiredError('describeTransactionRequest','Required parameter requestParameters.describeTransactionRequest was null or undefined when calling describeTransactionApiV1TransactionsDescribePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/describe`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DescribeTransactionRequestToJSON(requestParameters.describeTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DescribeTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get the current blockchain fee price and estimate the total transaction fee.
     * Describe Transaction
     */
    async describeTransactionApiV1TransactionsDescribePost(requestParameters: DescribeTransactionApiV1TransactionsDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DescribeTransactionResponse> {
        const response = await this.describeTransactionApiV1TransactionsDescribePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a CSV-format list of transactions.
     * Export Transactions
     */
    async exportTransactionsApiV1TransactionsExportGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get a CSV-format list of transactions.
     * Export Transactions
     */
    async exportTransactionsApiV1TransactionsExportGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.exportTransactionsApiV1TransactionsExportGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction
     */
    async getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNextApiSignerTransactionResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNextApiSignerTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction
     */
    async getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNextApiSignerTransactionResponse> {
        const response = await this.getNextApiSignerTransactionApiV1TransactionsNextApiSignerTransactionGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction V2
     */
    async getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2GetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetNextApiSignerTransactionResponseV2>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction_v2`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetNextApiSignerTransactionResponseV2FromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer.
     * Get Next Api Signer Transaction V2
     */
    async getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2Get(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetNextApiSignerTransactionResponseV2> {
        const response = await this.getNextApiSignerTransactionV2ApiV1TransactionsNextApiSignerTransactionV2GetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve transaction details.
     * Get Transaction
     */
    async getTransactionApiV1TransactionsIdGetRaw(requestParameters: GetTransactionApiV1TransactionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTransactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getTransactionApiV1TransactionsIdGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve transaction details.
     * Get Transaction
     */
    async getTransactionApiV1TransactionsIdGet(requestParameters: GetTransactionApiV1TransactionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTransactionResponse> {
        const response = await this.getTransactionApiV1TransactionsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all transactions in an organization.
     * List Transactions
     */
    async listTransactionsApiV1TransactionsGetRaw(requestParameters: ListTransactionsApiV1TransactionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTransactionResponse>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.createdBefore !== undefined) {
            queryParameters['created_before'] = (requestParameters.createdBefore as any).toISOString();
        }

        if (requestParameters.createdAfter !== undefined) {
            queryParameters['created_after'] = (requestParameters.createdAfter as any).toISOString();
        }

        if (requestParameters.modifiedAfter !== undefined) {
            queryParameters['modified_after'] = (requestParameters.modifiedAfter as any).toISOString();
        }

        if (requestParameters.vaultIds) {
            queryParameters['vault_ids'] = requestParameters.vaultIds;
        }

        if (requestParameters.chains) {
            queryParameters['chains'] = requestParameters.chains;
        }

        if (requestParameters.initiatorIds) {
            queryParameters['initiator_ids'] = requestParameters.initiatorIds;
        }

        if (requestParameters.states) {
            queryParameters['states'] = requestParameters.states;
        }

        if (requestParameters.types) {
            queryParameters['types'] = requestParameters.types;
        }

        if (requestParameters.subTypes) {
            queryParameters['sub_types'] = requestParameters.subTypes;
        }

        if (requestParameters.signerTypes) {
            queryParameters['signer_types'] = requestParameters.signerTypes;
        }

        if (requestParameters.transactionIds) {
            queryParameters['transaction_ids'] = requestParameters.transactionIds;
        }

        if (requestParameters.endUserIds) {
            queryParameters['end_user_ids'] = requestParameters.endUserIds;
        }

        if (requestParameters.isHidden !== undefined) {
            queryParameters['is_hidden'] = requestParameters.isHidden;
        }

        if (requestParameters.direction !== undefined) {
            queryParameters['direction'] = requestParameters.direction;
        }

        if (requestParameters.includeFullResponse !== undefined) {
            queryParameters['include_full_response'] = requestParameters.includeFullResponse;
        }

        if (requestParameters.sortBy) {
            queryParameters['sort_by'] = requestParameters.sortBy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all transactions in an organization.
     * List Transactions
     */
    async listTransactionsApiV1TransactionsGet(requestParameters: ListTransactionsApiV1TransactionsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTransactionResponse> {
        const response = await this.listTransactionsApiV1TransactionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Simulate the transaction and show the exact token\'s balance change, in addition to the fee estimation.
     * Predict Transaction
     */
    async predictTransactionApiV1TransactionsPredictPostRaw(requestParameters: PredictTransactionApiV1TransactionsPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PredictTransactionResponse>> {
        if (requestParameters.predictTransactionRequest === null || requestParameters.predictTransactionRequest === undefined) {
            throw new runtime.RequiredError('predictTransactionRequest','Required parameter requestParameters.predictTransactionRequest was null or undefined when calling predictTransactionApiV1TransactionsPredictPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/predict`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PredictTransactionRequestToJSON(requestParameters.predictTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PredictTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Simulate the transaction and show the exact token\'s balance change, in addition to the fee estimation.
     * Predict Transaction
     */
    async predictTransactionApiV1TransactionsPredictPost(requestParameters: PredictTransactionApiV1TransactionsPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PredictTransactionResponse> {
        const response = await this.predictTransactionApiV1TransactionsPredictPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V3
     */
    async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters: ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextApiSignerTransactionResponseV3>> {
        if (requestParameters.nextApiSignerTransactionRequestV3 === null || requestParameters.nextApiSignerTransactionRequestV3 === undefined) {
            throw new runtime.RequiredError('nextApiSignerTransactionRequestV3','Required parameter requestParameters.nextApiSignerTransactionRequestV3 was null or undefined when calling processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction_v3`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NextApiSignerTransactionRequestV3ToJSON(requestParameters.nextApiSignerTransactionRequestV3),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextApiSignerTransactionResponseV3FromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V3
     */
    async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post(requestParameters: ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextApiSignerTransactionResponseV3> {
        const response = await this.processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Push a transaction to the chain.
     * Push Transaction
     */
    async pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters: PushTransactionApiV1TransactionsIdPushPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PushTransactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost.');
        }

        if (requestParameters.pushTransactionRequest === null || requestParameters.pushTransactionRequest === undefined) {
            throw new runtime.RequiredError('pushTransactionRequest','Required parameter requestParameters.pushTransactionRequest was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/push`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PushTransactionRequestToJSON(requestParameters.pushTransactionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PushTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Push a transaction to the chain.
     * Push Transaction
     */
    async pushTransactionApiV1TransactionsIdPushPost(requestParameters: PushTransactionApiV1TransactionsIdPushPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PushTransactionResponse> {
        const response = await this.pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a sign-session for a transaction.
     * Register Transaction Sign Session
     */
    async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters: RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegisterTransactionSignSessionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost.');
        }

        if (requestParameters.registerTransactionSignSessionRequest === null || requestParameters.registerTransactionSignSessionRequest === undefined) {
            throw new runtime.RequiredError('registerTransactionSignSessionRequest','Required parameter requestParameters.registerTransactionSignSessionRequest was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/register-sign-session`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterTransactionSignSessionRequestToJSON(requestParameters.registerTransactionSignSessionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegisterTransactionSignSessionResponseFromJSON(jsonValue));
    }

    /**
     * Register a sign-session for a transaction.
     * Register Transaction Sign Session
     */
    async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost(requestParameters: RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegisterTransactionSignSessionResponse> {
        const response = await this.registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Release a transaction.
     * Release Transaction
     */
    async releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters: ReleaseTransactionApiV1TransactionsIdReleasePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReleaseTransactionResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xSignature !== undefined && requestParameters.xSignature !== null) {
            headerParameters['x-signature'] = String(requestParameters.xSignature);
        }

        if (requestParameters.xTimestamp !== undefined && requestParameters.xTimestamp !== null) {
            headerParameters['x-timestamp'] = String(requestParameters.xTimestamp);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/release`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReleaseEvmTransactionRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Release a transaction.
     * Release Transaction
     */
    async releaseTransactionApiV1TransactionsIdReleasePost(requestParameters: ReleaseTransactionApiV1TransactionsIdReleasePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReleaseTransactionResponse> {
        const response = await this.releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a signature for a transaction.
     * Submit Transaction Signature
     */
    async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters: SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/submit-signature`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Submit a signature for a transaction.
     * Submit Transaction Signature
     */
    async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost(requestParameters: SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a transaction before signing it.
     * Update Transaction For Signing
     */
    async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters: UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateTransactionForSigningResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/update-for-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateTransactionForSigningResponseFromJSON(jsonValue));
    }

    /**
     * Update a transaction before signing it.
     * Update Transaction For Signing
     */
    async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost(requestParameters: UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateTransactionForSigningResponse> {
        const response = await this.updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update transaction\'s spam state.
     * Update Transaction Spam State
     */
    async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters: UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut.');
        }

        if (requestParameters.updateTransactionSpamStateRequest === null || requestParameters.updateTransactionSpamStateRequest === undefined) {
            throw new runtime.RequiredError('updateTransactionSpamStateRequest','Required parameter requestParameters.updateTransactionSpamStateRequest was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/update-spam-state`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTransactionSpamStateRequestToJSON(requestParameters.updateTransactionSpamStateRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update transaction\'s spam state.
     * Update Transaction Spam State
     */
    async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut(requestParameters: UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters, initOverrides);
    }

}
