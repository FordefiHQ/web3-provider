/* tslint:disable */
/* eslint-disable */
/**
 * Fordefi API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BaseError,
  CreateTransactionRequest,
  CreateTransactionResponse,
  CreateTransactionWithWaitRequest,
  CreateTransactionWithWaitResponse,
  DefinedPreconditionErrorAbortTransactionErrorType,
  DefinedPreconditionErrorApproveTransactionErrorType,
  DefinedPreconditionErrorCreateTransactionErrorType,
  DefinedPreconditionErrorPredictTransactionErrorType,
  DefinedPreconditionErrorReleaseTransactionErrorType,
  DefinedPreconditionErrorSignTransactionErrorType,
  Export,
  GetTransactionResponse,
  ListTransactionResponse,
  NextApiSignerTransactionRequestV3,
  NextApiSignerTransactionRequestV4,
  NextApiSignerTransactionResponseV3,
  NextApiSignerTransactionResponseV4,
  PageResponseType,
  PreconditionFailedError,
  PredictTransactionRequest,
  PredictTransactionResponse,
  PushTransactionByDataRequest,
  PushTransactionByDataResponse,
  PushTransactionRequest,
  PushTransactionResponse,
  RefreshTransactionResponse,
  RegisterTransactionSignSessionRequest,
  RegisterTransactionSignSessionResponse,
  ReleaseTransactionRequest,
  ReleaseTransactionResponse,
  ResourceError,
  SignerType,
  StatesInner,
  TransactionDirection,
  TransactionSortableFields,
  TransactionSubType,
  TransactionType,
  TriggerAutoProtectionRequest,
  UpdateTransactionForSigningResponse,
  UpdateTransactionSpamStateRequest,
  ValidationError,
} from '../models/index';
import {
    BaseErrorFromJSON,
    BaseErrorToJSON,
    CreateTransactionRequestFromJSON,
    CreateTransactionRequestToJSON,
    CreateTransactionResponseFromJSON,
    CreateTransactionResponseToJSON,
    CreateTransactionWithWaitRequestFromJSON,
    CreateTransactionWithWaitRequestToJSON,
    CreateTransactionWithWaitResponseFromJSON,
    CreateTransactionWithWaitResponseToJSON,
    DefinedPreconditionErrorAbortTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorAbortTransactionErrorTypeToJSON,
    DefinedPreconditionErrorApproveTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorApproveTransactionErrorTypeToJSON,
    DefinedPreconditionErrorCreateTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorCreateTransactionErrorTypeToJSON,
    DefinedPreconditionErrorPredictTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorPredictTransactionErrorTypeToJSON,
    DefinedPreconditionErrorReleaseTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorReleaseTransactionErrorTypeToJSON,
    DefinedPreconditionErrorSignTransactionErrorTypeFromJSON,
    DefinedPreconditionErrorSignTransactionErrorTypeToJSON,
    ExportFromJSON,
    ExportToJSON,
    GetTransactionResponseFromJSON,
    GetTransactionResponseToJSON,
    ListTransactionResponseFromJSON,
    ListTransactionResponseToJSON,
    NextApiSignerTransactionRequestV3FromJSON,
    NextApiSignerTransactionRequestV3ToJSON,
    NextApiSignerTransactionRequestV4FromJSON,
    NextApiSignerTransactionRequestV4ToJSON,
    NextApiSignerTransactionResponseV3FromJSON,
    NextApiSignerTransactionResponseV3ToJSON,
    NextApiSignerTransactionResponseV4FromJSON,
    NextApiSignerTransactionResponseV4ToJSON,
    PageResponseTypeFromJSON,
    PageResponseTypeToJSON,
    PreconditionFailedErrorFromJSON,
    PreconditionFailedErrorToJSON,
    PredictTransactionRequestFromJSON,
    PredictTransactionRequestToJSON,
    PredictTransactionResponseFromJSON,
    PredictTransactionResponseToJSON,
    PushTransactionByDataRequestFromJSON,
    PushTransactionByDataRequestToJSON,
    PushTransactionByDataResponseFromJSON,
    PushTransactionByDataResponseToJSON,
    PushTransactionRequestFromJSON,
    PushTransactionRequestToJSON,
    PushTransactionResponseFromJSON,
    PushTransactionResponseToJSON,
    RefreshTransactionResponseFromJSON,
    RefreshTransactionResponseToJSON,
    RegisterTransactionSignSessionRequestFromJSON,
    RegisterTransactionSignSessionRequestToJSON,
    RegisterTransactionSignSessionResponseFromJSON,
    RegisterTransactionSignSessionResponseToJSON,
    ReleaseTransactionRequestFromJSON,
    ReleaseTransactionRequestToJSON,
    ReleaseTransactionResponseFromJSON,
    ReleaseTransactionResponseToJSON,
    ResourceErrorFromJSON,
    ResourceErrorToJSON,
    SignerTypeFromJSON,
    SignerTypeToJSON,
    StatesInnerFromJSON,
    StatesInnerToJSON,
    TransactionDirectionFromJSON,
    TransactionDirectionToJSON,
    TransactionSortableFieldsFromJSON,
    TransactionSortableFieldsToJSON,
    TransactionSubTypeFromJSON,
    TransactionSubTypeToJSON,
    TransactionTypeFromJSON,
    TransactionTypeToJSON,
    TriggerAutoProtectionRequestFromJSON,
    TriggerAutoProtectionRequestToJSON,
    UpdateTransactionForSigningResponseFromJSON,
    UpdateTransactionForSigningResponseToJSON,
    UpdateTransactionSpamStateRequestFromJSON,
    UpdateTransactionSpamStateRequestToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface AbortTransactionApiV1TransactionsIdAbortPostRequest {
    id: string;
}

export interface ApproveTransactionApiV1TransactionsIdApprovePostRequest {
    id: string;
}

export interface CreateTransactionAndWaitApiV1TransactionsCreateAndWaitPostRequest {
    createTransactionWithWaitRequest: CreateTransactionWithWaitRequest;
    xSignature?: string;
    xTimestamp?: number;
    xIdempotenceId?: string;
}

export interface CreateTransactionApiV1TransactionsPostRequest {
    createTransactionRequest: CreateTransactionRequest;
    xSignature?: string;
    xTimestamp?: number;
    xIdempotenceId?: string;
}

export interface ExportTransactionsApiV1TransactionsExportGetRequest {
    limit?: number;
    createdBefore?: Date;
    createdAfter?: Date;
    modifiedAfter?: Date;
    vaultIds?: Array<string>;
    chains?: Array<string>;
    initiatorIds?: Array<string>;
    types?: Array<TransactionType>;
    subTypes?: Array<TransactionSubType>;
    signerTypes?: Array<SignerType>;
    transactionIds?: Array<string>;
    endUserIds?: Array<string>;
    assetIds?: Array<string>;
    direction?: TransactionDirection;
    transactionHashes?: Array<string>;
    search?: string;
}

export interface GetTransactionApiV1TransactionsIdGetRequest {
    id: string;
}

export interface ListTransactionsApiV1TransactionsGetRequest {
    page?: number;
    size?: number;
    responseType?: PageResponseType;
    createdBefore?: Date;
    createdAfter?: Date;
    modifiedAfter?: Date;
    vaultIds?: Array<string>;
    chains?: Array<string>;
    initiatorIds?: Array<string>;
    types?: Array<TransactionType>;
    subTypes?: Array<TransactionSubType>;
    signerTypes?: Array<SignerType>;
    transactionIds?: Array<string>;
    endUserIds?: Array<string>;
    assetIds?: Array<string>;
    direction?: TransactionDirection;
    transactionHashes?: Array<string>;
    search?: string;
    states?: Array<StatesInner>;
    isHidden?: boolean;
    includeFullResponse?: boolean;
    batchIds?: Array<string>;
    includeBlackbox?: boolean;
    sortBy?: Array<TransactionSortableFields>;
}

export interface PredictTransactionApiV1TransactionsPredictPostRequest {
    predictTransactionRequest: PredictTransactionRequest;
}

export interface ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest {
    nextApiSignerTransactionRequestV3: NextApiSignerTransactionRequestV3;
}

export interface ProcessNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4PostRequest {
    nextApiSignerTransactionRequestV4: NextApiSignerTransactionRequestV4;
}

export interface PushTransactionApiV1TransactionsIdPushPostRequest {
    id: string;
    pushTransactionRequest: PushTransactionRequest;
}

export interface PushTransactionByDataApiV1TransactionsPushByDataPostRequest {
    pushTransactionByDataRequest: PushTransactionByDataRequest;
}

export interface RefreshTransactionApiV1TransactionsIdRefreshPostRequest {
    id: string;
}

export interface RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest {
    id: string;
    registerTransactionSignSessionRequest: RegisterTransactionSignSessionRequest;
}

export interface ReleaseTransactionApiV1TransactionsIdReleasePostRequest {
    id: string;
    releaseTransactionRequest: ReleaseTransactionRequest;
    xSignature?: string;
    xTimestamp?: number;
}

export interface SubmitToExchangeApiV1TransactionsIdSubmitToExchangePostRequest {
    id: string;
    body: object;
}

export interface SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest {
    id: string;
    body: object;
}

export interface TriggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRequest {
    triggerAutoProtectionRequest: TriggerAutoProtectionRequest;
}

export interface TriggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRequest {
    id: string;
}

export interface UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest {
    id: string;
    body: object;
}

export interface UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest {
    id: string;
    updateTransactionSpamStateRequest: UpdateTransactionSpamStateRequest;
}

/**
 * 
 */
export class TransactionsApi extends runtime.BaseAPI {

    /**
     * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
     * Abort Transaction
     */
    async abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters: AbortTransactionApiV1TransactionsIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling abortTransactionApiV1TransactionsIdAbortPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/abort`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Abort a transaction.  Abort is possible only for a transaction that is in one of the following states:    <ul>    <li>Waiting for approval    <li>Approved    </ul>  The aborting user must be one of the following: <ul> <li>The user who created the transaction <li>An admin <li>A legitimate approver </ul>  API users can abort only the transactions they created.
     * Abort Transaction
     */
    async abortTransactionApiV1TransactionsIdAbortPost(requestParameters: AbortTransactionApiV1TransactionsIdAbortPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.abortTransactionApiV1TransactionsIdAbortPostRaw(requestParameters, initOverrides);
    }

    /**
     * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
     * Approve Transaction
     */
    async approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters: ApproveTransactionApiV1TransactionsIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling approveTransactionApiV1TransactionsIdApprovePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/approve`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Approve a transaction.  A transaction awaits approval when the caller API user has been specified as a potential approver in the policy and the transaction is in the `waiting_for_approval` state.
     * Approve Transaction
     */
    async approveTransactionApiV1TransactionsIdApprovePost(requestParameters: ApproveTransactionApiV1TransactionsIdApprovePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.approveTransactionApiV1TransactionsIdApprovePostRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new transaction and wait until transaction reaches given state.
     * Create Transaction And Wait
     */
    async createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters: CreateTransactionAndWaitApiV1TransactionsCreateAndWaitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTransactionWithWaitResponse>> {
        if (requestParameters['createTransactionWithWaitRequest'] == null) {
            throw new runtime.RequiredError(
                'createTransactionWithWaitRequest',
                'Required parameter "createTransactionWithWaitRequest" was null or undefined when calling createTransactionAndWaitApiV1TransactionsCreateAndWaitPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xSignature'] != null) {
            headerParameters['x-signature'] = String(requestParameters['xSignature']);
        }

        if (requestParameters['xTimestamp'] != null) {
            headerParameters['x-timestamp'] = String(requestParameters['xTimestamp']);
        }

        if (requestParameters['xIdempotenceId'] != null) {
            headerParameters['x-idempotence-id'] = String(requestParameters['xIdempotenceId']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/create-and-wait`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTransactionWithWaitRequestToJSON(requestParameters['createTransactionWithWaitRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTransactionWithWaitResponseFromJSON(jsonValue));
    }

    /**
     * Create a new transaction and wait until transaction reaches given state.
     * Create Transaction And Wait
     */
    async createTransactionAndWaitApiV1TransactionsCreateAndWaitPost(requestParameters: CreateTransactionAndWaitApiV1TransactionsCreateAndWaitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTransactionWithWaitResponse> {
        const response = await this.createTransactionAndWaitApiV1TransactionsCreateAndWaitPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new transaction.
     * Create Transaction
     */
    async createTransactionApiV1TransactionsPostRaw(requestParameters: CreateTransactionApiV1TransactionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateTransactionResponse>> {
        if (requestParameters['createTransactionRequest'] == null) {
            throw new runtime.RequiredError(
                'createTransactionRequest',
                'Required parameter "createTransactionRequest" was null or undefined when calling createTransactionApiV1TransactionsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xSignature'] != null) {
            headerParameters['x-signature'] = String(requestParameters['xSignature']);
        }

        if (requestParameters['xTimestamp'] != null) {
            headerParameters['x-timestamp'] = String(requestParameters['xTimestamp']);
        }

        if (requestParameters['xIdempotenceId'] != null) {
            headerParameters['x-idempotence-id'] = String(requestParameters['xIdempotenceId']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateTransactionRequestToJSON(requestParameters['createTransactionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Create a new transaction.
     * Create Transaction
     */
    async createTransactionApiV1TransactionsPost(requestParameters: CreateTransactionApiV1TransactionsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateTransactionResponse> {
        const response = await this.createTransactionApiV1TransactionsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Start the export process for filtered transactions
     * Export Transactions
     */
    async exportTransactionsApiV1TransactionsExportGetRaw(requestParameters: ExportTransactionsApiV1TransactionsExportGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Export>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['created_before'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['created_after'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['modifiedAfter'] != null) {
            queryParameters['modified_after'] = (requestParameters['modifiedAfter'] as any).toISOString();
        }

        if (requestParameters['vaultIds'] != null) {
            queryParameters['vault_ids'] = requestParameters['vaultIds'];
        }

        if (requestParameters['chains'] != null) {
            queryParameters['chains'] = requestParameters['chains'];
        }

        if (requestParameters['initiatorIds'] != null) {
            queryParameters['initiator_ids'] = requestParameters['initiatorIds'];
        }

        if (requestParameters['types'] != null) {
            queryParameters['types'] = requestParameters['types'];
        }

        if (requestParameters['subTypes'] != null) {
            queryParameters['sub_types'] = requestParameters['subTypes'];
        }

        if (requestParameters['signerTypes'] != null) {
            queryParameters['signer_types'] = requestParameters['signerTypes'];
        }

        if (requestParameters['transactionIds'] != null) {
            queryParameters['transaction_ids'] = requestParameters['transactionIds'];
        }

        if (requestParameters['endUserIds'] != null) {
            queryParameters['end_user_ids'] = requestParameters['endUserIds'];
        }

        if (requestParameters['assetIds'] != null) {
            queryParameters['asset_ids'] = requestParameters['assetIds'];
        }

        if (requestParameters['direction'] != null) {
            queryParameters['direction'] = requestParameters['direction'];
        }

        if (requestParameters['transactionHashes'] != null) {
            queryParameters['transaction_hashes'] = requestParameters['transactionHashes'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/export`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportFromJSON(jsonValue));
    }

    /**
     * Start the export process for filtered transactions
     * Export Transactions
     */
    async exportTransactionsApiV1TransactionsExportGet(requestParameters: ExportTransactionsApiV1TransactionsExportGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Export | null | undefined > {
        const response = await this.exportTransactionsApiV1TransactionsExportGetRaw(requestParameters, initOverrides);
        switch (response.raw.status) {
            case 200:
                return await response.value();
            case 204:
                return null;
            default:
                return await response.value();
        }
    }

    /**
     * Retrieve transaction details.
     * Get Transaction
     */
    async getTransactionApiV1TransactionsIdGetRaw(requestParameters: GetTransactionApiV1TransactionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetTransactionResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getTransactionApiV1TransactionsIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve transaction details.
     * Get Transaction
     */
    async getTransactionApiV1TransactionsIdGet(requestParameters: GetTransactionApiV1TransactionsIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetTransactionResponse> {
        const response = await this.getTransactionApiV1TransactionsIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all transactions in an organization.
     * List Transactions
     */
    async listTransactionsApiV1TransactionsGetRaw(requestParameters: ListTransactionsApiV1TransactionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListTransactionResponse>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['responseType'] != null) {
            queryParameters['response_type'] = requestParameters['responseType'];
        }

        if (requestParameters['createdBefore'] != null) {
            queryParameters['created_before'] = (requestParameters['createdBefore'] as any).toISOString();
        }

        if (requestParameters['createdAfter'] != null) {
            queryParameters['created_after'] = (requestParameters['createdAfter'] as any).toISOString();
        }

        if (requestParameters['modifiedAfter'] != null) {
            queryParameters['modified_after'] = (requestParameters['modifiedAfter'] as any).toISOString();
        }

        if (requestParameters['vaultIds'] != null) {
            queryParameters['vault_ids'] = requestParameters['vaultIds'];
        }

        if (requestParameters['chains'] != null) {
            queryParameters['chains'] = requestParameters['chains'];
        }

        if (requestParameters['initiatorIds'] != null) {
            queryParameters['initiator_ids'] = requestParameters['initiatorIds'];
        }

        if (requestParameters['types'] != null) {
            queryParameters['types'] = requestParameters['types'];
        }

        if (requestParameters['subTypes'] != null) {
            queryParameters['sub_types'] = requestParameters['subTypes'];
        }

        if (requestParameters['signerTypes'] != null) {
            queryParameters['signer_types'] = requestParameters['signerTypes'];
        }

        if (requestParameters['transactionIds'] != null) {
            queryParameters['transaction_ids'] = requestParameters['transactionIds'];
        }

        if (requestParameters['endUserIds'] != null) {
            queryParameters['end_user_ids'] = requestParameters['endUserIds'];
        }

        if (requestParameters['assetIds'] != null) {
            queryParameters['asset_ids'] = requestParameters['assetIds'];
        }

        if (requestParameters['direction'] != null) {
            queryParameters['direction'] = requestParameters['direction'];
        }

        if (requestParameters['transactionHashes'] != null) {
            queryParameters['transaction_hashes'] = requestParameters['transactionHashes'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['states'] != null) {
            queryParameters['states'] = requestParameters['states'];
        }

        if (requestParameters['isHidden'] != null) {
            queryParameters['is_hidden'] = requestParameters['isHidden'];
        }

        if (requestParameters['includeFullResponse'] != null) {
            queryParameters['include_full_response'] = requestParameters['includeFullResponse'];
        }

        if (requestParameters['batchIds'] != null) {
            queryParameters['batch_ids'] = requestParameters['batchIds'];
        }

        if (requestParameters['includeBlackbox'] != null) {
            queryParameters['include_blackbox'] = requestParameters['includeBlackbox'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all transactions in an organization.
     * List Transactions
     */
    async listTransactionsApiV1TransactionsGet(requestParameters: ListTransactionsApiV1TransactionsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListTransactionResponse> {
        const response = await this.listTransactionsApiV1TransactionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Simulate the transaction and changes in token balances, in addition to the fee estimation.
     * Predict Transaction
     */
    async predictTransactionApiV1TransactionsPredictPostRaw(requestParameters: PredictTransactionApiV1TransactionsPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PredictTransactionResponse>> {
        if (requestParameters['predictTransactionRequest'] == null) {
            throw new runtime.RequiredError(
                'predictTransactionRequest',
                'Required parameter "predictTransactionRequest" was null or undefined when calling predictTransactionApiV1TransactionsPredictPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/predict`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PredictTransactionRequestToJSON(requestParameters['predictTransactionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PredictTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Simulate the transaction and changes in token balances, in addition to the fee estimation.
     * Predict Transaction
     */
    async predictTransactionApiV1TransactionsPredictPost(requestParameters: PredictTransactionApiV1TransactionsPredictPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PredictTransactionResponse> {
        const response = await this.predictTransactionApiV1TransactionsPredictPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V3
     */
    async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters: ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextApiSignerTransactionResponseV3>> {
        if (requestParameters['nextApiSignerTransactionRequestV3'] == null) {
            throw new runtime.RequiredError(
                'nextApiSignerTransactionRequestV3',
                'Required parameter "nextApiSignerTransactionRequestV3" was null or undefined when calling processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction_v3`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NextApiSignerTransactionRequestV3ToJSON(requestParameters['nextApiSignerTransactionRequestV3']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextApiSignerTransactionResponseV3FromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V3
     */
    async processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3Post(requestParameters: ProcessNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextApiSignerTransactionResponseV3> {
        const response = await this.processNextApiSignerTransactionV3ApiV1TransactionsNextApiSignerTransactionV3PostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V4
     */
    async processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4PostRaw(requestParameters: ProcessNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextApiSignerTransactionResponseV4>> {
        if (requestParameters['nextApiSignerTransactionRequestV4'] == null) {
            throw new runtime.RequiredError(
                'nextApiSignerTransactionRequestV4',
                'Required parameter "nextApiSignerTransactionRequestV4" was null or undefined when calling processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4Post().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/next_api_signer_transaction_v4`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NextApiSignerTransactionRequestV4ToJSON(requestParameters['nextApiSignerTransactionRequestV4']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextApiSignerTransactionResponseV4FromJSON(jsonValue));
    }

    /**
     * Get the first transaction ready for signing by api-signer while it already registered for signing.
     * Process Next Api Signer Transaction V4
     */
    async processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4Post(requestParameters: ProcessNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4PostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextApiSignerTransactionResponseV4> {
        const response = await this.processNextApiSignerTransactionV4ApiV1TransactionsNextApiSignerTransactionV4PostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Push an existing signed transaction to the chain. The transaction must have been previously created with a `push_mode: manual` flag and must now be in state `signed`.
     * Push Transaction
     */
    async pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters: PushTransactionApiV1TransactionsIdPushPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PushTransactionResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost().'
            );
        }

        if (requestParameters['pushTransactionRequest'] == null) {
            throw new runtime.RequiredError(
                'pushTransactionRequest',
                'Required parameter "pushTransactionRequest" was null or undefined when calling pushTransactionApiV1TransactionsIdPushPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/push`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PushTransactionRequestToJSON(requestParameters['pushTransactionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PushTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Push an existing signed transaction to the chain. The transaction must have been previously created with a `push_mode: manual` flag and must now be in state `signed`.
     * Push Transaction
     */
    async pushTransactionApiV1TransactionsIdPushPost(requestParameters: PushTransactionApiV1TransactionsIdPushPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PushTransactionResponse> {
        const response = await this.pushTransactionApiV1TransactionsIdPushPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Push a transaction to the chain, the transaction is identified by its data.
     * Push Transaction By Data
     */
    async pushTransactionByDataApiV1TransactionsPushByDataPostRaw(requestParameters: PushTransactionByDataApiV1TransactionsPushByDataPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PushTransactionByDataResponse>> {
        if (requestParameters['pushTransactionByDataRequest'] == null) {
            throw new runtime.RequiredError(
                'pushTransactionByDataRequest',
                'Required parameter "pushTransactionByDataRequest" was null or undefined when calling pushTransactionByDataApiV1TransactionsPushByDataPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/push-by-data`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PushTransactionByDataRequestToJSON(requestParameters['pushTransactionByDataRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PushTransactionByDataResponseFromJSON(jsonValue));
    }

    /**
     * Push a transaction to the chain, the transaction is identified by its data.
     * Push Transaction By Data
     */
    async pushTransactionByDataApiV1TransactionsPushByDataPost(requestParameters: PushTransactionByDataApiV1TransactionsPushByDataPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PushTransactionByDataResponse> {
        const response = await this.pushTransactionByDataApiV1TransactionsPushByDataPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Refresh a transaction.
     * Refresh Transaction
     */
    async refreshTransactionApiV1TransactionsIdRefreshPostRaw(requestParameters: RefreshTransactionApiV1TransactionsIdRefreshPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RefreshTransactionResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling refreshTransactionApiV1TransactionsIdRefreshPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/refresh`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RefreshTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Refresh a transaction.
     * Refresh Transaction
     */
    async refreshTransactionApiV1TransactionsIdRefreshPost(requestParameters: RefreshTransactionApiV1TransactionsIdRefreshPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RefreshTransactionResponse> {
        const response = await this.refreshTransactionApiV1TransactionsIdRefreshPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a sign-session for a transaction.
     * Register Transaction Sign Session
     */
    async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters: RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegisterTransactionSignSessionResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost().'
            );
        }

        if (requestParameters['registerTransactionSignSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'registerTransactionSignSessionRequest',
                'Required parameter "registerTransactionSignSessionRequest" was null or undefined when calling registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/register-sign-session`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterTransactionSignSessionRequestToJSON(requestParameters['registerTransactionSignSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegisterTransactionSignSessionResponseFromJSON(jsonValue));
    }

    /**
     * Register a sign-session for a transaction.
     * Register Transaction Sign Session
     */
    async registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPost(requestParameters: RegisterTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegisterTransactionSignSessionResponse> {
        const response = await this.registerTransactionSignSessionApiV1TransactionsIdRegisterSignSessionPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Release a transaction.
     * Release Transaction
     */
    async releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters: ReleaseTransactionApiV1TransactionsIdReleasePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReleaseTransactionResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost().'
            );
        }

        if (requestParameters['releaseTransactionRequest'] == null) {
            throw new runtime.RequiredError(
                'releaseTransactionRequest',
                'Required parameter "releaseTransactionRequest" was null or undefined when calling releaseTransactionApiV1TransactionsIdReleasePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['xSignature'] != null) {
            headerParameters['x-signature'] = String(requestParameters['xSignature']);
        }

        if (requestParameters['xTimestamp'] != null) {
            headerParameters['x-timestamp'] = String(requestParameters['xTimestamp']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/release`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReleaseTransactionRequestToJSON(requestParameters['releaseTransactionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReleaseTransactionResponseFromJSON(jsonValue));
    }

    /**
     * Release a transaction.
     * Release Transaction
     */
    async releaseTransactionApiV1TransactionsIdReleasePost(requestParameters: ReleaseTransactionApiV1TransactionsIdReleasePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReleaseTransactionResponse> {
        const response = await this.releaseTransactionApiV1TransactionsIdReleasePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit transaction to exchange.
     * Submit To Exchange
     */
    async submitToExchangeApiV1TransactionsIdSubmitToExchangePostRaw(requestParameters: SubmitToExchangeApiV1TransactionsIdSubmitToExchangePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling submitToExchangeApiV1TransactionsIdSubmitToExchangePost().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling submitToExchangeApiV1TransactionsIdSubmitToExchangePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/submit-to-exchange`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Submit transaction to exchange.
     * Submit To Exchange
     */
    async submitToExchangeApiV1TransactionsIdSubmitToExchangePost(requestParameters: SubmitToExchangeApiV1TransactionsIdSubmitToExchangePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.submitToExchangeApiV1TransactionsIdSubmitToExchangePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Submit a signature for a transaction.
     * Submit Transaction Signature
     */
    async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters: SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/submit-signature`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Submit a signature for a transaction.
     * Submit Transaction Signature
     */
    async submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePost(requestParameters: SubmitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.submitTransactionSignatureApiV1TransactionsIdSubmitSignaturePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trigger transaction auto revoke protection.
     * Trigger Auto Revoke Protection
     */
    async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters: TriggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['triggerAutoProtectionRequest'] == null) {
            throw new runtime.RequiredError(
                'triggerAutoProtectionRequest',
                'Required parameter "triggerAutoProtectionRequest" was null or undefined when calling triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/trigger-auto-revoke-protection`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TriggerAutoProtectionRequestToJSON(requestParameters['triggerAutoProtectionRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger transaction auto revoke protection.
     * Trigger Auto Revoke Protection
     */
    async triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPost(requestParameters: TriggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.triggerAutoRevokeProtectionApiV1TransactionsTriggerAutoRevokeProtectionPostRaw(requestParameters, initOverrides);
    }

    /**
     * Trigger transaction signing.
     * Trigger Transaction Signing
     */
    async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters: TriggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/trigger-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Trigger transaction signing.
     * Trigger Transaction Signing
     */
    async triggerTransactionSigningApiV1TransactionsIdTriggerSigningPost(requestParameters: TriggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.triggerTransactionSigningApiV1TransactionsIdTriggerSigningPostRaw(requestParameters, initOverrides);
    }

    /**
     * Update a transaction before signing it.
     * Update Transaction For Signing
     */
    async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters: UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateTransactionForSigningResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/update-for-signing`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateTransactionForSigningResponseFromJSON(jsonValue));
    }

    /**
     * Update a transaction before signing it.
     * Update Transaction For Signing
     */
    async updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPost(requestParameters: UpdateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateTransactionForSigningResponse> {
        const response = await this.updateTransactionForSigningApiV1TransactionsIdUpdateForSigningPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update transaction\'s spam state.
     * Update Transaction Spam State
     */
    async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters: UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut().'
            );
        }

        if (requestParameters['updateTransactionSpamStateRequest'] == null) {
            throw new runtime.RequiredError(
                'updateTransactionSpamStateRequest',
                'Required parameter "updateTransactionSpamStateRequest" was null or undefined when calling updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/transactions/{id}/update-spam-state`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateTransactionSpamStateRequestToJSON(requestParameters['updateTransactionSpamStateRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update transaction\'s spam state.
     * Update Transaction Spam State
     */
    async updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePut(requestParameters: UpdateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateTransactionSpamStateApiV1TransactionsIdUpdateSpamStatePutRaw(requestParameters, initOverrides);
    }

}
