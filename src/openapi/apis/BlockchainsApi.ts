/* tslint:disable */
/* eslint-disable */
/**
 * Fordefi API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddChainRequest,
  BaseError,
  ChainSource,
  ChainType,
  DefinedPreconditionErrorBlockchainErrorType,
  DefinedPreconditionErrorTestChainErrorType,
  GetRpcEndpointsResponse,
  GetSuggestedFeesResponse,
  ListBlockchainsResponse,
  ListDappsResponse,
  ListEIP712Domains,
  ListEIP712PrimaryTypes,
  PageResponseType,
  PreconditionFailedError,
  ResourceError,
  TestChainRequest,
  UpdateChainRequest,
  ValidationError,
} from '../models/index';
import {
    AddChainRequestFromJSON,
    AddChainRequestToJSON,
    BaseErrorFromJSON,
    BaseErrorToJSON,
    ChainSourceFromJSON,
    ChainSourceToJSON,
    ChainTypeFromJSON,
    ChainTypeToJSON,
    DefinedPreconditionErrorBlockchainErrorTypeFromJSON,
    DefinedPreconditionErrorBlockchainErrorTypeToJSON,
    DefinedPreconditionErrorTestChainErrorTypeFromJSON,
    DefinedPreconditionErrorTestChainErrorTypeToJSON,
    GetRpcEndpointsResponseFromJSON,
    GetRpcEndpointsResponseToJSON,
    GetSuggestedFeesResponseFromJSON,
    GetSuggestedFeesResponseToJSON,
    ListBlockchainsResponseFromJSON,
    ListBlockchainsResponseToJSON,
    ListDappsResponseFromJSON,
    ListDappsResponseToJSON,
    ListEIP712DomainsFromJSON,
    ListEIP712DomainsToJSON,
    ListEIP712PrimaryTypesFromJSON,
    ListEIP712PrimaryTypesToJSON,
    PageResponseTypeFromJSON,
    PageResponseTypeToJSON,
    PreconditionFailedErrorFromJSON,
    PreconditionFailedErrorToJSON,
    ResourceErrorFromJSON,
    ResourceErrorToJSON,
    TestChainRequestFromJSON,
    TestChainRequestToJSON,
    UpdateChainRequestFromJSON,
    UpdateChainRequestToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface AddChainApiV1BlockchainsPostRequest {
    addChainRequest: AddChainRequest;
}

export interface CustomChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRequest {
    chainId: string;
    organizationId: string;
}

export interface DisableBlockchainApiV1BlockchainsChainDisablePostRequest {
    chain: string;
}

export interface EnableBlockchainApiV1BlockchainsChainEnablePostRequest {
    chain: string;
}

export interface GetSuggestedFeesApiV1BlockchainsSuggestedFeesGetRequest {
    chains?: Array<string>;
    chainTypes?: Array<ChainType>;
}

export interface ListChainsApiV1BlockchainsGetRequest {
    page?: number;
    size?: number;
    responseType?: PageResponseType;
    chainTypes?: Array<ChainType>;
    sources?: Array<ChainSource>;
    onlyInteractedWith?: boolean;
    search?: string;
    includeMainnets?: boolean;
    includeTestnets?: boolean;
    includeExchanges?: boolean;
    showAll?: boolean;
}

export interface ListDappsApiV1BlockchainsDappsGetRequest {
    page?: number;
    size?: number;
    responseType?: PageResponseType;
    search?: string;
    dappIds?: Array<string>;
}

export interface ListInteractedEip712DomainsApiV1BlockchainsEip712DomainsGetRequest {
    page?: number;
    size?: number;
    responseType?: PageResponseType;
    search?: string;
    primaryTypes?: Array<string>;
}

export interface ListInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGetRequest {
    page?: number;
    size?: number;
    responseType?: PageResponseType;
    search?: string;
    domains?: Array<string>;
}

export interface TestRpcApiV1BlockchainsTestRpcPostRequest {
    testChainRequest: TestChainRequest;
}

export interface UpdateChainApiV1BlockchainsPutRequest {
    updateChainRequest: UpdateChainRequest;
}

/**
 * 
 */
export class BlockchainsApi extends runtime.BaseAPI {

    /**
     * add a new custom chain.
     * Add Chain
     */
    async addChainApiV1BlockchainsPostRaw(requestParameters: AddChainApiV1BlockchainsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['addChainRequest'] == null) {
            throw new runtime.RequiredError(
                'addChainRequest',
                'Required parameter "addChainRequest" was null or undefined when calling addChainApiV1BlockchainsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddChainRequestToJSON(requestParameters['addChainRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * add a new custom chain.
     * Add Chain
     */
    async addChainApiV1BlockchainsPost(requestParameters: AddChainApiV1BlockchainsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.addChainApiV1BlockchainsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Issue a custom rpc command.
     * Custom Chain Rpc
     */
    async customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRaw(requestParameters: CustomChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['chainId'] == null) {
            throw new runtime.RequiredError(
                'chainId',
                'Required parameter "chainId" was null or undefined when calling customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost().'
            );
        }

        if (requestParameters['organizationId'] == null) {
            throw new runtime.RequiredError(
                'organizationId',
                'Required parameter "organizationId" was null or undefined when calling customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/rpc/evm/custom-chain-rpc/{organization_id}/{chain_id}`.replace(`{${"chain_id"}}`, encodeURIComponent(String(requestParameters['chainId']))).replace(`{${"organization_id"}}`, encodeURIComponent(String(requestParameters['organizationId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Issue a custom rpc command.
     * Custom Chain Rpc
     */
    async customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPost(requestParameters: CustomChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.customChainRpcApiV1BlockchainsRpcEvmCustomChainRpcOrganizationIdChainIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Disable a blockchain for the organization.
     * Disable Blockchain
     */
    async disableBlockchainApiV1BlockchainsChainDisablePostRaw(requestParameters: DisableBlockchainApiV1BlockchainsChainDisablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['chain'] == null) {
            throw new runtime.RequiredError(
                'chain',
                'Required parameter "chain" was null or undefined when calling disableBlockchainApiV1BlockchainsChainDisablePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/{chain}/disable`.replace(`{${"chain"}}`, encodeURIComponent(String(requestParameters['chain']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Disable a blockchain for the organization.
     * Disable Blockchain
     */
    async disableBlockchainApiV1BlockchainsChainDisablePost(requestParameters: DisableBlockchainApiV1BlockchainsChainDisablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.disableBlockchainApiV1BlockchainsChainDisablePostRaw(requestParameters, initOverrides);
    }

    /**
     * Enable a blockchain for the organization.
     * Enable Blockchain
     */
    async enableBlockchainApiV1BlockchainsChainEnablePostRaw(requestParameters: EnableBlockchainApiV1BlockchainsChainEnablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['chain'] == null) {
            throw new runtime.RequiredError(
                'chain',
                'Required parameter "chain" was null or undefined when calling enableBlockchainApiV1BlockchainsChainEnablePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/{chain}/enable`.replace(`{${"chain"}}`, encodeURIComponent(String(requestParameters['chain']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enable a blockchain for the organization.
     * Enable Blockchain
     */
    async enableBlockchainApiV1BlockchainsChainEnablePost(requestParameters: EnableBlockchainApiV1BlockchainsChainEnablePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableBlockchainApiV1BlockchainsChainEnablePostRaw(requestParameters, initOverrides);
    }

    /**
     * Get the suggested fees in a specific network.
     * Get Rpc Endpoints
     */
    async getRpcEndpointsApiV1BlockchainsRpcEndpointsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRpcEndpointsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/rpc-endpoints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetRpcEndpointsResponseFromJSON(jsonValue));
    }

    /**
     * Get the suggested fees in a specific network.
     * Get Rpc Endpoints
     */
    async getRpcEndpointsApiV1BlockchainsRpcEndpointsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRpcEndpointsResponse> {
        const response = await this.getRpcEndpointsApiV1BlockchainsRpcEndpointsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get the suggested fees in a specific network.
     * Get Suggested Fees
     */
    async getSuggestedFeesApiV1BlockchainsSuggestedFeesGetRaw(requestParameters: GetSuggestedFeesApiV1BlockchainsSuggestedFeesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSuggestedFeesResponse>> {
        const queryParameters: any = {};

        if (requestParameters['chains'] != null) {
            queryParameters['chains'] = requestParameters['chains'];
        }

        if (requestParameters['chainTypes'] != null) {
            queryParameters['chain_types'] = requestParameters['chainTypes'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/suggested-fees`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetSuggestedFeesResponseFromJSON(jsonValue));
    }

    /**
     * Get the suggested fees in a specific network.
     * Get Suggested Fees
     */
    async getSuggestedFeesApiV1BlockchainsSuggestedFeesGet(requestParameters: GetSuggestedFeesApiV1BlockchainsSuggestedFeesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSuggestedFeesResponse> {
        const response = await this.getSuggestedFeesApiV1BlockchainsSuggestedFeesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of supported blockchains.
     * List Chains
     */
    async listChainsApiV1BlockchainsGetRaw(requestParameters: ListChainsApiV1BlockchainsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListBlockchainsResponse>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['responseType'] != null) {
            queryParameters['response_type'] = requestParameters['responseType'];
        }

        if (requestParameters['chainTypes'] != null) {
            queryParameters['chain_types'] = requestParameters['chainTypes'];
        }

        if (requestParameters['sources'] != null) {
            queryParameters['sources'] = requestParameters['sources'];
        }

        if (requestParameters['onlyInteractedWith'] != null) {
            queryParameters['only_interacted_with'] = requestParameters['onlyInteractedWith'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['includeMainnets'] != null) {
            queryParameters['include_mainnets'] = requestParameters['includeMainnets'];
        }

        if (requestParameters['includeTestnets'] != null) {
            queryParameters['include_testnets'] = requestParameters['includeTestnets'];
        }

        if (requestParameters['includeExchanges'] != null) {
            queryParameters['include_exchanges'] = requestParameters['includeExchanges'];
        }

        if (requestParameters['showAll'] != null) {
            queryParameters['show_all'] = requestParameters['showAll'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListBlockchainsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of supported blockchains.
     * List Chains
     */
    async listChainsApiV1BlockchainsGet(requestParameters: ListChainsApiV1BlockchainsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListBlockchainsResponse> {
        const response = await this.listChainsApiV1BlockchainsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all supported dapps.
     * List Dapps
     */
    async listDappsApiV1BlockchainsDappsGetRaw(requestParameters: ListDappsApiV1BlockchainsDappsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListDappsResponse>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['responseType'] != null) {
            queryParameters['response_type'] = requestParameters['responseType'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['dappIds'] != null) {
            queryParameters['dapp_ids'] = requestParameters['dappIds'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/dapps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListDappsResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of all supported dapps.
     * List Dapps
     */
    async listDappsApiV1BlockchainsDappsGet(requestParameters: ListDappsApiV1BlockchainsDappsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListDappsResponse> {
        const response = await this.listDappsApiV1BlockchainsDappsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all interacted eip712 domains.
     * List Interacted Eip712 Domains
     */
    async listInteractedEip712DomainsApiV1BlockchainsEip712DomainsGetRaw(requestParameters: ListInteractedEip712DomainsApiV1BlockchainsEip712DomainsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListEIP712Domains>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['responseType'] != null) {
            queryParameters['response_type'] = requestParameters['responseType'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['primaryTypes'] != null) {
            queryParameters['primary_types'] = requestParameters['primaryTypes'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/eip712-domains`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListEIP712DomainsFromJSON(jsonValue));
    }

    /**
     * Get a list of all interacted eip712 domains.
     * List Interacted Eip712 Domains
     */
    async listInteractedEip712DomainsApiV1BlockchainsEip712DomainsGet(requestParameters: ListInteractedEip712DomainsApiV1BlockchainsEip712DomainsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListEIP712Domains> {
        const response = await this.listInteractedEip712DomainsApiV1BlockchainsEip712DomainsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all interacted eip712 primary types.
     * List Interacted Eip712 Primary Types
     */
    async listInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGetRaw(requestParameters: ListInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListEIP712PrimaryTypes>> {
        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['size'] != null) {
            queryParameters['size'] = requestParameters['size'];
        }

        if (requestParameters['responseType'] != null) {
            queryParameters['response_type'] = requestParameters['responseType'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['domains'] != null) {
            queryParameters['domains'] = requestParameters['domains'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/eip712-primary-types`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListEIP712PrimaryTypesFromJSON(jsonValue));
    }

    /**
     * Get a list of all interacted eip712 primary types.
     * List Interacted Eip712 Primary Types
     */
    async listInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGet(requestParameters: ListInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListEIP712PrimaryTypes> {
        const response = await this.listInteractedEip712PrimaryTypesApiV1BlockchainsEip712PrimaryTypesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Test the RPC connection to a custom chain.
     * Test Rpc
     */
    async testRpcApiV1BlockchainsTestRpcPostRaw(requestParameters: TestRpcApiV1BlockchainsTestRpcPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['testChainRequest'] == null) {
            throw new runtime.RequiredError(
                'testChainRequest',
                'Required parameter "testChainRequest" was null or undefined when calling testRpcApiV1BlockchainsTestRpcPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains/test-rpc`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TestChainRequestToJSON(requestParameters['testChainRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Test the RPC connection to a custom chain.
     * Test Rpc
     */
    async testRpcApiV1BlockchainsTestRpcPost(requestParameters: TestRpcApiV1BlockchainsTestRpcPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.testRpcApiV1BlockchainsTestRpcPostRaw(requestParameters, initOverrides);
    }

    /**
     * update a custom chain.
     * Update Chain
     */
    async updateChainApiV1BlockchainsPutRaw(requestParameters: UpdateChainApiV1BlockchainsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['updateChainRequest'] == null) {
            throw new runtime.RequiredError(
                'updateChainRequest',
                'Required parameter "updateChainRequest" was null or undefined when calling updateChainApiV1BlockchainsPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/blockchains`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateChainRequestToJSON(requestParameters['updateChainRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * update a custom chain.
     * Update Chain
     */
    async updateChainApiV1BlockchainsPut(requestParameters: UpdateChainApiV1BlockchainsPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateChainApiV1BlockchainsPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
