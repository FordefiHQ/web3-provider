/* tslint:disable */
/* eslint-disable */
/**
 * Fordefi API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { ActionSigningRequest } from './ActionSigningRequest';
import {
    ActionSigningRequestFromJSON,
    ActionSigningRequestFromJSONTyped,
    ActionSigningRequestToJSON,
} from './ActionSigningRequest';
import type { ApprovalRequest } from './ApprovalRequest';
import {
    ApprovalRequestFromJSON,
    ApprovalRequestFromJSONTyped,
    ApprovalRequestToJSON,
} from './ApprovalRequest';
import type { BatchData } from './BatchData';
import {
    BatchDataFromJSON,
    BatchDataFromJSONTyped,
    BatchDataToJSON,
} from './BatchData';
import type { PolicyMatch } from './PolicyMatch';
import {
    PolicyMatchFromJSON,
    PolicyMatchFromJSONTyped,
    PolicyMatchToJSON,
} from './PolicyMatch';
import type { PushMode } from './PushMode';
import {
    PushModeFromJSON,
    PushModeFromJSONTyped,
    PushModeToJSON,
} from './PushMode';
import type { SignMode } from './SignMode';
import {
    SignModeFromJSON,
    SignModeFromJSONTyped,
    SignModeToJSON,
} from './SignMode';
import type { SignerType } from './SignerType';
import {
    SignerTypeFromJSON,
    SignerTypeFromJSONTyped,
    SignerTypeToJSON,
} from './SignerType';
import type { TransactionRisk } from './TransactionRisk';
import {
    TransactionRiskFromJSON,
    TransactionRiskFromJSONTyped,
    TransactionRiskToJSON,
} from './TransactionRisk';
import type { UserRef } from './UserRef';
import {
    UserRefFromJSON,
    UserRefFromJSONTyped,
    UserRefToJSON,
} from './UserRef';
import type { VaultRef } from './VaultRef';
import {
    VaultRefFromJSON,
    VaultRefFromJSONTyped,
    VaultRefToJSON,
} from './VaultRef';

/**
 * 
 * @export
 * @interface ManagedTransactionData
 */
export interface ManagedTransactionData {
    /**
     * 
     * @type {UserRef}
     * @memberof ManagedTransactionData
     */
    createdBy: UserRef;
    /**
     * 
     * @type {UserRef}
     * @memberof ManagedTransactionData
     */
    abortedBy?: UserRef;
    /**
     * 
     * @type {ActionSigningRequest}
     * @memberof ManagedTransactionData
     */
    deviceSigningRequest?: ActionSigningRequest;
    /**
     * 
     * @type {ApprovalRequest}
     * @memberof ManagedTransactionData
     */
    approvalRequest?: ApprovalRequest;
    /**
     * 
     * @type {PolicyMatch}
     * @memberof ManagedTransactionData
     */
    policyMatch?: PolicyMatch;
    /**
     * 
     * @type {SignerType}
     * @memberof ManagedTransactionData
     */
    signerType: SignerType;
    /**
     * 
     * @type {Array<TransactionRisk>}
     * @memberof ManagedTransactionData
     */
    risks: Array<TransactionRisk>;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionData
     */
    errorPushingToBlockchainMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionData
     */
    originalErrorPushingToBlockchainMessage?: string;
    /**
     * 
     * @type {VaultRef}
     * @memberof ManagedTransactionData
     */
    vault: VaultRef;
    /**
     * 
     * @type {string}
     * @memberof ManagedTransactionData
     */
    idempotenceId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ManagedTransactionData
     */
    hasCurrentUserVaultPermissions: boolean;
    /**
     * 
     * @type {BatchData}
     * @memberof ManagedTransactionData
     */
    batchData?: BatchData;
    /**
     * 
     * @type {PushMode}
     * @memberof ManagedTransactionData
     */
    pushMode?: PushMode;
    /**
     * 
     * @type {Date}
     * @memberof ManagedTransactionData
     */
    lastPushedAt?: Date;
    /**
     * 
     * @type {SignMode}
     * @memberof ManagedTransactionData
     */
    signMode?: SignMode;
}

/**
 * Check if a given object implements the ManagedTransactionData interface.
 */
export function instanceOfManagedTransactionData(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "createdBy" in value;
    isInstance = isInstance && "signerType" in value;
    isInstance = isInstance && "risks" in value;
    isInstance = isInstance && "vault" in value;
    isInstance = isInstance && "hasCurrentUserVaultPermissions" in value;

    return isInstance;
}

export function ManagedTransactionDataFromJSON(json: any): ManagedTransactionData {
    return ManagedTransactionDataFromJSONTyped(json, false);
}

export function ManagedTransactionDataFromJSONTyped(json: any, ignoreDiscriminator: boolean): ManagedTransactionData {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'createdBy': UserRefFromJSON(json['created_by']),
        'abortedBy': !exists(json, 'aborted_by') ? undefined : UserRefFromJSON(json['aborted_by']),
        'deviceSigningRequest': !exists(json, 'device_signing_request') ? undefined : ActionSigningRequestFromJSON(json['device_signing_request']),
        'approvalRequest': !exists(json, 'approval_request') ? undefined : ApprovalRequestFromJSON(json['approval_request']),
        'policyMatch': !exists(json, 'policy_match') ? undefined : PolicyMatchFromJSON(json['policy_match']),
        'signerType': SignerTypeFromJSON(json['signer_type']),
        'risks': ((json['risks'] as Array<any>).map(TransactionRiskFromJSON)),
        'errorPushingToBlockchainMessage': !exists(json, 'error_pushing_to_blockchain_message') ? undefined : json['error_pushing_to_blockchain_message'],
        'originalErrorPushingToBlockchainMessage': !exists(json, 'original_error_pushing_to_blockchain_message') ? undefined : json['original_error_pushing_to_blockchain_message'],
        'vault': VaultRefFromJSON(json['vault']),
        'idempotenceId': !exists(json, 'idempotence_id') ? undefined : json['idempotence_id'],
        'hasCurrentUserVaultPermissions': json['has_current_user_vault_permissions'],
        'batchData': !exists(json, 'batch_data') ? undefined : BatchDataFromJSON(json['batch_data']),
        'pushMode': !exists(json, 'push_mode') ? undefined : PushModeFromJSON(json['push_mode']),
        'lastPushedAt': !exists(json, 'last_pushed_at') ? undefined : (new Date(json['last_pushed_at'])),
        'signMode': !exists(json, 'sign_mode') ? undefined : SignModeFromJSON(json['sign_mode']),
    };
}

export function ManagedTransactionDataToJSON(value?: ManagedTransactionData | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'created_by': UserRefToJSON(value.createdBy),
        'aborted_by': UserRefToJSON(value.abortedBy),
        'device_signing_request': ActionSigningRequestToJSON(value.deviceSigningRequest),
        'approval_request': ApprovalRequestToJSON(value.approvalRequest),
        'policy_match': PolicyMatchToJSON(value.policyMatch),
        'signer_type': SignerTypeToJSON(value.signerType),
        'risks': ((value.risks as Array<any>).map(TransactionRiskToJSON)),
        'error_pushing_to_blockchain_message': value.errorPushingToBlockchainMessage,
        'original_error_pushing_to_blockchain_message': value.originalErrorPushingToBlockchainMessage,
        'vault': VaultRefToJSON(value.vault),
        'idempotence_id': value.idempotenceId,
        'has_current_user_vault_permissions': value.hasCurrentUserVaultPermissions,
        'batch_data': BatchDataToJSON(value.batchData),
        'push_mode': PushModeToJSON(value.pushMode),
        'last_pushed_at': value.lastPushedAt === undefined ? undefined : (value.lastPushedAt.toISOString()),
        'sign_mode': SignModeToJSON(value.signMode),
    };
}

